<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MatrixBerryCore: mxberry::core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MatrixBerryCore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemxberry.html">mxberry</a></li><li class="navelem"><a class="el" href="namespacemxberry_1_1core.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mxberry::core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1cell"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1cell.html">cell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1check"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1check.html">check</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1cont"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1cont.html">cont</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1obj"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1obj.html">obj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1sort"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1sort.html">sort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1string"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1string.html">string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1struct"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html">struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1type.html">type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxberry_1_1core_1_1_m_exception_utils.html">MExceptionUtils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98e8bb81bc575e2cc6441035b6a9c0e1"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a98e8bb81bc575e2cc6441035b6a9c0e1">absrelcompare</a> (in leftArr, in rightArr, in absTol, in relTol, in fNormOp)</td></tr>
<tr class="memdesc:a98e8bb81bc575e2cc6441035b6a9c0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ABSRELCOMPARE - compares two numerical arrays by user defined norm. For each two corresponding fNormOp input elements from the leftArr (argL) and the rightArr (argR) the function calculates:  <a href="#a98e8bb81bc575e2cc6441035b6a9c0e1">More...</a><br /></td></tr>
<tr class="separator:a98e8bb81bc575e2cc6441035b6a9c0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec438edf5f022eb82a835ea2c3664fc"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a6ec438edf5f022eb82a835ea2c3664fc">cat</a> (in dimNum, in varargin)</td></tr>
<tr class="separator:a6ec438edf5f022eb82a835ea2c3664fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1efaf84ab63c12b637ada14051eb9"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a58c1efaf84ab63c12b637ada14051eb9">cellfunallelem</a> (in hFunc, in inpCell, in varargin)</td></tr>
<tr class="memdesc:a58c1efaf84ab63c12b637ada14051eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CELLFUNALLELEM applies the specified function to all elements in each cell of the specified cell array and returns array of results for each cell.  <a href="#a58c1efaf84ab63c12b637ada14051eb9">More...</a><br /></td></tr>
<tr class="separator:a58c1efaf84ab63c12b637ada14051eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91d54fe4a96d73126bf0db4994aa138"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#af91d54fe4a96d73126bf0db4994aa138">checkmultvar</a> (in typeSpec, in nPlaceHolders, in varargin)</td></tr>
<tr class="memdesc:af91d54fe4a96d73126bf0db4994aa138"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKMULTVAR checks a generic condition provided by typeSpec string in the following format: 'isnumeric(x1)&amp;&amp;isa(x2,'int32')||isscalar(x2)' etc In case validation fails an exception is thrown.  <a href="#af91d54fe4a96d73126bf0db4994aa138">More...</a><br /></td></tr>
<tr class="separator:af91d54fe4a96d73126bf0db4994aa138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2068d2cb829d65d298d869bc0f4da2f7"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a2068d2cb829d65d298d869bc0f4da2f7">assignIn</a> (in varName, in varValue)</td></tr>
<tr class="separator:a2068d2cb829d65d298d869bc0f4da2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01601968dba093ead278e8f4626d75ab"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a01601968dba093ead278e8f4626d75ab">checksize</a> (in varargin)</td></tr>
<tr class="memdesc:a01601968dba093ead278e8f4626d75ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKSIZE checks sizes of arrays;.  <a href="#a01601968dba093ead278e8f4626d75ab">More...</a><br /></td></tr>
<tr class="separator:a01601968dba093ead278e8f4626d75ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3801c283d9a35a44097046e5b2757975"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a3801c283d9a35a44097046e5b2757975">checkvar</a> (in x, in typeSpec, in varargin)</td></tr>
<tr class="memdesc:a3801c283d9a35a44097046e5b2757975"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHECKVAR checks a generic condition provided by typeSpec string in the following format: 'isnumeric(x)&amp;&amp;isa(x,'int32')||isscalar(x)' etc In case validation fails an exception is thrown.  <a href="#a3801c283d9a35a44097046e5b2757975">More...</a><br /></td></tr>
<tr class="separator:a3801c283d9a35a44097046e5b2757975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50a33874c11cfdc98b0591918ccd88d"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ad50a33874c11cfdc98b0591918ccd88d">combvec</a> (in varargin)</td></tr>
<tr class="memdesc:ad50a33874c11cfdc98b0591918ccd88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">COMBVEC creates a matrix of combinations with elements from input vectors.  <a href="#ad50a33874c11cfdc98b0591918ccd88d">More...</a><br /></td></tr>
<tr class="separator:ad50a33874c11cfdc98b0591918ccd88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1e065d0d5734cb5596e4e033d3d9d6"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a0d1e065d0d5734cb5596e4e033d3d9d6">addBlockedInd</a> (in indMat, in nElems)</td></tr>
<tr class="separator:a0d1e065d0d5734cb5596e4e033d3d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e021591b526cae0107e5418517e6e4a"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a8e021591b526cae0107e5418517e6e4a">addInterleavedInd</a> (in indMat, in nElems)</td></tr>
<tr class="separator:a8e021591b526cae0107e5418517e6e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bee4f5988ab992a2e92437560be80a"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ac6bee4f5988ab992a2e92437560be80a">createarray</a> (in varargin)</td></tr>
<tr class="separator:ac6bee4f5988ab992a2e92437560be80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab4d9b0f9250251d7f6c8cef9ab467d"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a7ab4d9b0f9250251d7f6c8cef9ab467d">genfilename</a> (in inpStr)</td></tr>
<tr class="memdesc:a7ab4d9b0f9250251d7f6c8cef9ab467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GENFILENAME generates a valid file name based on a given string.  <a href="#a7ab4d9b0f9250251d7f6c8cef9ab467d">More...</a><br /></td></tr>
<tr class="separator:a7ab4d9b0f9250251d7f6c8cef9ab467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202a9ab0574c2b9892097c5f34363591"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a202a9ab0574c2b9892097c5f34363591">genteststruct</a> (in inpNum)</td></tr>
<tr class="memdesc:a202a9ab0574c2b9892097c5f34363591"><td class="mdescLeft">&#160;</td><td class="mdescRight">GENTESTSTRUCT generates a complex test structure using input number to guarantee a uniqueness.  <a href="#a202a9ab0574c2b9892097c5f34363591">More...</a><br /></td></tr>
<tr class="separator:a202a9ab0574c2b9892097c5f34363591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbbf1cf602d8cfc82b5986b75558aca"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a1dbbf1cf602d8cfc82b5986b75558aca">filesep</a> ()</td></tr>
<tr class="separator:a1dbbf1cf602d8cfc82b5986b75558aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b769cc418c56926472a9306de4e4c8b"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a5b769cc418c56926472a9306de4e4c8b">getcallername</a> (in nStepsUp, in mode)</td></tr>
<tr class="memdesc:a5b769cc418c56926472a9306de4e4c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GETCALLERNAME returns a name of caller determined by a number of steps up in the call stacks.  <a href="#a5b769cc418c56926472a9306de4e4c8b">More...</a><br /></td></tr>
<tr class="separator:a5b769cc418c56926472a9306de4e4c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8533542a3914319395013ae4d7e0ed"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a1f8533542a3914319395013ae4d7e0ed">getcallernameext</a> (in indStack)</td></tr>
<tr class="memdesc:a1f8533542a3914319395013ae4d7e0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">GETCALLERNAME determines function/script name or method name of caller together with class name in the case it is method of class for element of stack given by its index (this index is 1 for immediate caller of this function)  <a href="#a1f8533542a3914319395013ae4d7e0ed">More...</a><br /></td></tr>
<tr class="separator:a1f8533542a3914319395013ae4d7e0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952b1b3051fc7c3c12f91b199cf8fba7"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a952b1b3051fc7c3c12f91b199cf8fba7">getfirstdimsize</a> (in value, in nDims)</td></tr>
<tr class="memdesc:a952b1b3051fc7c3c12f91b199cf8fba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GETFIRSTDIMSIZE returns a size vector for the first N dimensions where N is specified.  <a href="#a952b1b3051fc7c3c12f91b199cf8fba7">More...</a><br /></td></tr>
<tr class="separator:a952b1b3051fc7c3c12f91b199cf8fba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6e3dc28b4b9ee8110355245399146"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ac0d6e3dc28b4b9ee8110355245399146">hash</a> (in inpArr, in methodName)</td></tr>
<tr class="memdesc:ac0d6e3dc28b4b9ee8110355245399146"><td class="mdescLeft">&#160;</td><td class="mdescRight">OBJECTHASH counts the hash of input object/array.  <a href="#ac0d6e3dc28b4b9ee8110355245399146">More...</a><br /></td></tr>
<tr class="separator:ac0d6e3dc28b4b9ee8110355245399146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b9de2eb47a731374160c16463c0223"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a71b9de2eb47a731374160c16463c0223">structhash</a> (in structB, in methodName)</td></tr>
<tr class="separator:a71b9de2eb47a731374160c16463c0223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b6ffc35791ffdb63d2c58dd4aa0415"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a25b6ffc35791ffdb63d2c58dd4aa0415">cellhash</a> (in cellB, in methodName)</td></tr>
<tr class="separator:a25b6ffc35791ffdb63d2c58dd4aa0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39d705c2fd83dfb2f141212f4e334bf"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ae39d705c2fd83dfb2f141212f4e334bf">hashinner</a> (in inpArr, in meth)</td></tr>
<tr class="memdesc:ae39d705c2fd83dfb2f141212f4e334bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">HASH - Convert an input variable into a message digest using any of several common hash algorithms.  <a href="#ae39d705c2fd83dfb2f141212f4e334bf">More...</a><br /></td></tr>
<tr class="separator:ae39d705c2fd83dfb2f141212f4e334bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561fa6e98a53b94b60600171acaffb7d"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a561fa6e98a53b94b60600171acaffb7d">ind2submat</a> (in sizeVec, in indVec)</td></tr>
<tr class="memdesc:a561fa6e98a53b94b60600171acaffb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">IND2SUBMAT works similarly to the built-in ind2sub function but returns all the indices in a single matrix.  <a href="#a561fa6e98a53b94b60600171acaffb7d">More...</a><br /></td></tr>
<tr class="separator:a561fa6e98a53b94b60600171acaffb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b876ee82367a95297f3ab6931f2ab4"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a52b876ee82367a95297f3ab6931f2ab4">iscelllogical</a> (in value)</td></tr>
<tr class="separator:a52b876ee82367a95297f3ab6931f2ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109461a1489d1f085bc4da56824f5c21"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a109461a1489d1f085bc4da56824f5c21">iscellnumeric</a> (in valueArr)</td></tr>
<tr class="memdesc:a109461a1489d1f085bc4da56824f5c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISCELLNUMERIC returns true for a cell arrays consisting of numeric elements only.  <a href="#a109461a1489d1f085bc4da56824f5c21">More...</a><br /></td></tr>
<tr class="separator:a109461a1489d1f085bc4da56824f5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ab1159da81deb069aaa27924d7567b"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a24ab1159da81deb069aaa27924d7567b">iscol</a> (in inpArray)</td></tr>
<tr class="separator:a24ab1159da81deb069aaa27924d7567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e153653f73e458cc27d8d71bdf31ad"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ac2e153653f73e458cc27d8d71bdf31ad">isequalcellelemsize</a> (in value1, in value2)</td></tr>
<tr class="separator:ac2e153653f73e458cc27d8d71bdf31ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f589319675f973249a1bc82f7d3ac39"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a6f589319675f973249a1bc82f7d3ac39">isequalfirstdimsize</a> (in firstArr, in secArr, in nDims)</td></tr>
<tr class="memdesc:a6f589319675f973249a1bc82f7d3ac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISEQUALFIRSTDIMSIZE checks if the specified arrays have the same size along the first N dimensions where N is specified.  <a href="#a6f589319675f973249a1bc82f7d3ac39">More...</a><br /></td></tr>
<tr class="separator:a6f589319675f973249a1bc82f7d3ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153b3936f6081b928368044bdfa108bb"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a153b3936f6081b928368044bdfa108bb">isfirstdimsizeasspecified</a> (in valueArr, in sizeVec)</td></tr>
<tr class="memdesc:a153b3936f6081b928368044bdfa108bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISFIRSTDIMSIZEASSPECIFIED check if an input value have a specified size along the first dimensions.  <a href="#a153b3936f6081b928368044bdfa108bb">More...</a><br /></td></tr>
<tr class="separator:a153b3936f6081b928368044bdfa108bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128281605e1d3cd50f5879cedf252829"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a128281605e1d3cd50f5879cedf252829">ismember</a> (in leftVec, in rightVec, in varargin)</td></tr>
<tr class="memdesc:a128281605e1d3cd50f5879cedf252829"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBER - ismember implementation for arrays of any type.  <a href="#a128281605e1d3cd50f5879cedf252829">More...</a><br /></td></tr>
<tr class="separator:a128281605e1d3cd50f5879cedf252829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace30cc5c07da6840ac0c59ba60af812f"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ace30cc5c07da6840ac0c59ba60af812f">ismemberbyfunc</a> (in leftVec, in rightVec, in fCompare)</td></tr>
<tr class="memdesc:ace30cc5c07da6840ac0c59ba60af812f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBERBYFUNC - ismember implementation for arrays of any type where an element comparison is performed by a specified function. This function is useful when elements are not sortable i.e. EITHER an implementation of ,,,,, does not define a full order OR there is no an implementation of  method that calls these operators.  <a href="#ace30cc5c07da6840ac0c59ba60af812f">More...</a><br /></td></tr>
<tr class="separator:ace30cc5c07da6840ac0c59ba60af812f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7325f54bcfc06a4e4beb9d2038be34d9"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a7325f54bcfc06a4e4beb9d2038be34d9">ismembercellstr</a> (in leftList, in rightList, in isHigherIndexUsed)</td></tr>
<tr class="memdesc:a7325f54bcfc06a4e4beb9d2038be34d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBERCELLSTR produces the same results as the built-in function "ismember" looking for the higher index if isHigherIndexUsed =true and lower index if isHigherIndexUsed=false (default)  <a href="#a7325f54bcfc06a4e4beb9d2038be34d9">More...</a><br /></td></tr>
<tr class="separator:a7325f54bcfc06a4e4beb9d2038be34d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85cadd1e23943f4244537dec5b7466"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#afc85cadd1e23943f4244537dec5b7466">ismemberjoint</a> (in leftCArr, in rightCArr, in varargin)</td></tr>
<tr class="memdesc:afc85cadd1e23943f4244537dec5b7466"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBERJOINT perform joint ismember operation for two cell arrays.  <a href="#afc85cadd1e23943f4244537dec5b7466">More...</a><br /></td></tr>
<tr class="separator:afc85cadd1e23943f4244537dec5b7466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fe0487e0a2ec01e41433b24dbc69d3"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a97fe0487e0a2ec01e41433b24dbc69d3">ismemberjointwithnulls</a> (in leftCVec, in leftIsNullCVec, in rightCVec, in rightIsNullCVec, in dim)</td></tr>
<tr class="memdesc:a97fe0487e0a2ec01e41433b24dbc69d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBERJOINTWITHNULLS perform joint ismember operation for two cell arrays for which also cell arrays detemining positions of null values are given.  <a href="#a97fe0487e0a2ec01e41433b24dbc69d3">More...</a><br /></td></tr>
<tr class="separator:a97fe0487e0a2ec01e41433b24dbc69d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3984640ce480d5ab2ce2ac3bece4880f"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a3984640ce480d5ab2ce2ac3bece4880f">checkValueAndIsNullConsistency</a> (in nameStr, in valueCVec, in isNullCVec, in nDimsCVec, in isnValueVec)</td></tr>
<tr class="separator:a3984640ce480d5ab2ce2ac3bece4880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824002c60eb4a84bc32715fcb944fef"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ad824002c60eb4a84bc32715fcb944fef">ismemberrows</a> (in inpLeftMat, in inpRightMat, in isInteger, in forceMode)</td></tr>
<tr class="memdesc:ad824002c60eb4a84bc32715fcb944fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBERROWS finds indices of rows from the first matrix in the second matrix, i.e. it is the more efficient version of ISMEMBER(,'rows')  <a href="#ad824002c60eb4a84bc32715fcb944fef">More...</a><br /></td></tr>
<tr class="separator:ad824002c60eb4a84bc32715fcb944fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86d152881e2cdd55fe7249e2b6d7ba"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a9d86d152881e2cdd55fe7249e2b6d7ba">ismembersortableobj</a> (in firstVec, in secVec)</td></tr>
<tr class="memdesc:a9d86d152881e2cdd55fe7249e2b6d7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISMEMBER implementation strictly for sortable entities i.e. for those that have 1) full order defined by implementation of comparison operators /isequal/isequaln/isequaln, , , , ,  2) an implementation of  method that uses these operators.  <a href="#a9d86d152881e2cdd55fe7249e2b6d7ba">More...</a><br /></td></tr>
<tr class="separator:a9d86d152881e2cdd55fe7249e2b6d7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689f4e3e7f0a7816ca4c5b24338bbc7a"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a689f4e3e7f0a7816ca4c5b24338bbc7a">isrow</a> (in inpArray)</td></tr>
<tr class="separator:a689f4e3e7f0a7816ca4c5b24338bbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0bfe26af5d0622daabdb7737c6dbf7"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ade0bfe26af5d0622daabdb7737c6dbf7">isunique</a> (in inpVec)</td></tr>
<tr class="separator:ade0bfe26af5d0622daabdb7737c6dbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9595b6be2f2b7b8a2e664921ae8faa96"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a9595b6be2f2b7b8a2e664921ae8faa96">isvalidsize</a> (in varargin)</td></tr>
<tr class="memdesc:a9595b6be2f2b7b8a2e664921ae8faa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISVALIDSIZE compares size of input arrays with size mask. Size mask can contain nans that allow any size for a corresponding dimension. Function automatically adds 1 at the end of size. For example, array 3x2 is also array 3x2x1 and 3x2x1x1x1 e.t.c;.  <a href="#a9595b6be2f2b7b8a2e664921ae8faa96">More...</a><br /></td></tr>
<tr class="separator:a9595b6be2f2b7b8a2e664921ae8faa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1edec5e1786e3aa6d8aabd094f07127"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#af1edec5e1786e3aa6d8aabd094f07127">isvar</a> (in varName)</td></tr>
<tr class="separator:af1edec5e1786e3aa6d8aabd094f07127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc4013e2e25384e1b5e4c3365c7a4a5"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#acdc4013e2e25384e1b5e4c3365c7a4a5">isvec</a> (in inpArray)</td></tr>
<tr class="separator:acdc4013e2e25384e1b5e4c3365c7a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef6bf81b31117d7bc0664e07ac47b45"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a4ef6bf81b31117d7bc0664e07ac47b45">num2cell</a> (in inpArray, in varargin)</td></tr>
<tr class="memdesc:a4ef6bf81b31117d7bc0664e07ac47b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUM2CELL is an extension of Matlab built-in function "num2cell" designed to work correctly with empty arrays (such as zero(10,0)) for instance.  <a href="#a4ef6bf81b31117d7bc0664e07ac47b45">More...</a><br /></td></tr>
<tr class="separator:a4ef6bf81b31117d7bc0664e07ac47b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aace73b15b9a8915fef9c3d853a107d"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a4aace73b15b9a8915fef9c3d853a107d">parseparams</a> (in args, in propNameList, in nRegExpected, in nPropExpected)</td></tr>
<tr class="memdesc:a4aace73b15b9a8915fef9c3d853a107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">PARSEPARAMS behaves exactly as a built-in Matlab function apart from the incorrect behavior of Matlab function in cases when the regular argument has a character type. Additionally the function allows to avoid a misinterpretation of symbolical values of regular parameters via listing all the allowed properties.  <a href="#a4aace73b15b9a8915fef9c3d853a107d">More...</a><br /></td></tr>
<tr class="separator:a4aace73b15b9a8915fef9c3d853a107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4280be33b62043e3b51cac0cd2422f"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a1d4280be33b62043e3b51cac0cd2422f">parseparext</a> (in args, in propNameValMat, in varargin)</td></tr>
<tr class="memdesc:a1d4280be33b62043e3b51cac0cd2422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PARSEPAREXT behaves in the same way as <a class="el" href="namespacemxberry_1_1core.html#a4aace73b15b9a8915fef9c3d853a107d" title="PARSEPARAMS behaves exactly as a built-in Matlab function apart from the incorrect behavior of Matlab...">mxberry.core.parseparams</a> but returns property values in a more convenient form.  <a href="#a1d4280be33b62043e3b51cac0cd2422f">More...</a><br /></td></tr>
<tr class="separator:a1d4280be33b62043e3b51cac0cd2422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340f01d626482c5df08f7efc25b2c03"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#aa340f01d626482c5df08f7efc25b2c03">parsestackelem</a> (in SStackElem)</td></tr>
<tr class="memdesc:aa340f01d626482c5df08f7efc25b2c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">PARSESTACKELEM parses structure for given element of stack and returns the corresponding function/script name or method name together with class name in the case the element corresponds to some method of class.  <a href="#aa340f01d626482c5df08f7efc25b2c03">More...</a><br /></td></tr>
<tr class="separator:aa340f01d626482c5df08f7efc25b2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4013c197c3314c7c61f1abb527cddf8"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#af4013c197c3314c7c61f1abb527cddf8">repmat</a> (in inpArray, in varargin)</td></tr>
<tr class="separator:af4013c197c3314c7c61f1abb527cddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff1ae4d47f235066962004643956ff6"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a4ff1ae4d47f235066962004643956ff6">roundn</a> (in inpArr, in indexExp)</td></tr>
<tr class="memdesc:a4ff1ae4d47f235066962004643956ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROUNDN rounds to multiple of 10^indexExp.  <a href="#a4ff1ae4d47f235066962004643956ff6">More...</a><br /></td></tr>
<tr class="separator:a4ff1ae4d47f235066962004643956ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02140bbba59721d1ddec37ff7d03512"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ad02140bbba59721d1ddec37ff7d03512">subreffrontdim</a> (in inpArray, in curInd)</td></tr>
<tr class="separator:ad02140bbba59721d1ddec37ff7d03512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0418f02bf5876d905979cce7b8fdf7ae"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a0418f02bf5876d905979cce7b8fdf7ae">throwerror</a> (in msgTag, in varargin)</td></tr>
<tr class="memdesc:a0418f02bf5876d905979cce7b8fdf7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">THROWERROR works similarly to built-in ERROR function in case when there is no output arguments but simpler to use as it automatically generates tags based on caller name When output argument is specified an exception object is returned instead.  <a href="#a0418f02bf5876d905979cce7b8fdf7ae">More...</a><br /></td></tr>
<tr class="separator:a0418f02bf5876d905979cce7b8fdf7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e469edaaf6fd2957f785d6523cdfe45"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a4e469edaaf6fd2957f785d6523cdfe45">unionjoint</a> (in leftCell, in rightCell)</td></tr>
<tr class="memdesc:a4e469edaaf6fd2957f785d6523cdfe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIONJOINT calculates union of corresponding elements of two cell arrays jointly accross all cell array elements.  <a href="#a4e469edaaf6fd2957f785d6523cdfe45">More...</a><br /></td></tr>
<tr class="separator:a4e469edaaf6fd2957f785d6523cdfe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34e5aaef1ed1c0bb395f7923ba05275"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ad34e5aaef1ed1c0bb395f7923ba05275">smartcat</a> (in xArray, in yArray)</td></tr>
<tr class="separator:ad34e5aaef1ed1c0bb395f7923ba05275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683f057478002dffe1fb0b609d149032"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a683f057478002dffe1fb0b609d149032">unique</a> (in inpVec)</td></tr>
<tr class="memdesc:a683f057478002dffe1fb0b609d149032"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIQUE for arrays of any type.  <a href="#a683f057478002dffe1fb0b609d149032">More...</a><br /></td></tr>
<tr class="separator:a683f057478002dffe1fb0b609d149032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dfbf027fe35478bed638e0bd8b1cd2"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a84dfbf027fe35478bed638e0bd8b1cd2">uniquebyfunc</a> (in inpVec, in fCompare, in algoName)</td></tr>
<tr class="memdesc:a84dfbf027fe35478bed638e0bd8b1cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIQUEBYFUNC unique for arrays of any type where an element comparison is performed by a specified function.  <a href="#a84dfbf027fe35478bed638e0bd8b1cd2">More...</a><br /></td></tr>
<tr class="separator:a84dfbf027fe35478bed638e0bd8b1cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bf89f7fac5aec4aa10028a947f56c2"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#ac4bf89f7fac5aec4aa10028a947f56c2">uniquejoint</a> (in inpCArr, in varargin)</td></tr>
<tr class="memdesc:ac4bf89f7fac5aec4aa10028a947f56c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIQUEJOINT perform joint unique operation for cell arrays.  <a href="#ac4bf89f7fac5aec4aa10028a947f56c2">More...</a><br /></td></tr>
<tr class="separator:ac4bf89f7fac5aec4aa10028a947f56c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0019e12ebaeeade8bd08d11595154661"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a0019e12ebaeeade8bd08d11595154661">uniquerows</a> (in inpMat, in isInteger, in forceMode)</td></tr>
<tr class="memdesc:a0019e12ebaeeade8bd08d11595154661"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIQUEROWS finds unique rows in input matrix, i.e. the more effective version of UNIQUE(,'rows')  <a href="#a0019e12ebaeeade8bd08d11595154661">More...</a><br /></td></tr>
<tr class="separator:a0019e12ebaeeade8bd08d11595154661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284ef547f3c9309906dd48d454cf71c0"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core.html#a284ef547f3c9309906dd48d454cf71c0">uniquesortableobj</a> (in inpVec)</td></tr>
<tr class="memdesc:a284ef547f3c9309906dd48d454cf71c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIQUE implementation strictly for sortable entities i.e. for those that have 1) full order defined by implementation of comparison operators /isequal/isequaln/isequaln, , , , ,  2) an implementation of  method that uses these operators.  <a href="#a284ef547f3c9309906dd48d454cf71c0">More...</a><br /></td></tr>
<tr class="separator:a284ef547f3c9309906dd48d454cf71c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a98e8bb81bc575e2cc6441035b6a9c0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e8bb81bc575e2cc6441035b6a9c0e1">&#9670;&nbsp;</a></span>absrelcompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::absrelcompare </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fNormOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ABSRELCOMPARE - compares two numerical arrays by user defined norm. For each two corresponding fNormOp input elements from the leftArr (argL) and the rightArr (argR) the function calculates: </p>
<pre class="fragment">*    1) Absolute difference if:
*         fNormOp(argL - argR) &lt;= absTol
*    or
*         fNormOp(argL) + fNormOp(argR) &lt;= absTol.
* 
*    The absolute difference is calculated as:
*         fNormOp(argL - argR)
* 
*    2) Absolute and relative difference in other cases. The relative
*    difference is calculated as:
* 
*         2 * fNormOp(argL - argR) / (fNormOp(argL) + fNormOp(argR))
* 
*    The maximum absolute difference for all elements is returned as
*    absDiff. If the relative difference has been calculated for some
*    elements, then the relative difference value for maximum element
*    returns as relDiff, the maximum absolute difference for this element as
*    absMRelDiff.
* 
* 
*  Input:
*      regular:
* 
*          leftArr, rightArr: double[nElemsDim1,, nElemsDimk] - input
*                             arrays with the same size.
* 
*          absTol: double[1, 1] - the absolute difference calculation
*                  threshold for the algorithm. If relTol is empty, the
*                  absTol is the maximum allowed absolute tolerance.
* 
*          relTol: double[1, 1] - the maximum allowed relative tolerance. If
*                  it is empty, then relative precision isn't calculated.
* 
*          fNormOp: function_handle[1, 1] - norm(x) operator handle. The
*                   function must have the format:
* 
*                   normArr = fNormOp(inpArr)
* 
*                        Input:
*                            inpArr: double[nElemsDim1,, nElemsDimk] - an
*                                    input array.
* 
*                        Output:
*                            normArr: double[..] - an output array with norm
*                                     for each element. The type of
*                                     element is specified by user (it can
*                                     be the vector, for example), so the
*                                     numerical array normArr can have any
*                                     size. The only condition is:
* 
*                                        size(fNormOp(inp1Arr)) == %&gt;                                           size(fNormOp(inp2Arr)),
* 
*                                     for all inp1Arr and inp2Arr with the
*                                     same size.
* 
*  Output:
* 
*          isEqual: logical[1, 1] - are two input arrays equal with defined
*                   tolerances.
* 
*          absDiff: double[1, 1] - the maximum absolute difference (from all
*                   elements).
* 
*          isRelDiffTriggered: logical[1, 1] - has the relative comparison
*                              been used.
* 
*          relDiff: double[1, 1] - the maximum relative difference (from all
*                   elements for which it was calculated). If the relative
*                   comparison hasn't been used, it is empty.
* 
*          absMRelDiff: double[1, 1] - the absolute difference for the
*                       element with maximum relative difference value. If
*                       there are more elemets than one with the same
*                       relative difference value, then the maximum absolute
*                       difference value among them is returned. If the
*                       relative comparison hasn't been used, it is empty.
* 
*          reportStr: char[1,..] standart error report or empty string if no
*                     error has occured.
* 
*  Example:
*      If you want to compare only absolute difference with absTol, you can
*      use:
* 
*          [isEqual, absDiff] = absrelcompare(aArr, bArr, absTol, [], @abs)
* 
*      If you want to compare only relative difference with relTol, you can
*      use:
* 
*          [isEqual, ~, ~, relDiff] = %&gt;               absrelcompare(aArr, bArr, Inf, relTol, @abs)
* 
*      You also can compare relative difference between two vectors norm:
* 
*          [isEqual, ~, ~, relDiff] = %&gt;               absrelcompare(aVec, bVec, Inf, relTol, @norm)
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>,<br />
 Yuri Admiralsky <a href="#" onclick="location.href='mai'+'lto:'+'swi'+'ge'+'.id'+'e@'+'gma'+'il'+'.co'+'m'; return false;">swige<span style="display: none;">.nosp@m.</span>.ide<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a0d1e065d0d5734cb5596e4e033d3d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1e065d0d5734cb5596e4e033d3d9d6">&#9670;&nbsp;</a></span>addBlockedInd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::addBlockedInd </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>indMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nElems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e021591b526cae0107e5418517e6e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e021591b526cae0107e5418517e6e4a">&#9670;&nbsp;</a></span>addInterleavedInd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::addInterleavedInd </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>indMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nElems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2068d2cb829d65d298d869bc0f4da2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2068d2cb829d65d298d869bc0f4da2f7">&#9670;&nbsp;</a></span>assignIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::assignIn </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ec438edf5f022eb82a835ea2c3664fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec438edf5f022eb82a835ea2c3664fc">&#9670;&nbsp;</a></span>cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::cat </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>dimNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a58c1efaf84ab63c12b637ada14051eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c1efaf84ab63c12b637ada14051eb9">&#9670;&nbsp;</a></span>cellfunallelem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::cellfunallelem </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>hFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CELLFUNALLELEM applies the specified function to all elements in each cell of the specified cell array and returns array of results for each cell. </p>
<pre class="fragment">*  Input:
*    regular:
*        hFunc: function_handle[1,1] - function to apply to all elements
*        inpCell: cell[nElem1,,nElemN] - input array
* 
*    properties:
*        same properties as a built-in cellfun function
*           (UniformOutput for instance is supported)
* 
*  Output:
*    resArray: numeric/logical[nElem1,,nElemN] - calcualtion result
* 
* 
*  Example:
*    mxberry.core.cellfunallelem(@any,{true,[false true;true true]})
*    ans =
*         1     1
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a25b6ffc35791ffdb63d2c58dd4aa0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b6ffc35791ffdb63d2c58dd4aa0415">&#9670;&nbsp;</a></span>cellhash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::cellhash </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>cellB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>methodName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af91d54fe4a96d73126bf0db4994aa138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91d54fe4a96d73126bf0db4994aa138">&#9670;&nbsp;</a></span>checkmultvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::checkmultvar </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>typeSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nPlaceHolders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHECKMULTVAR checks a generic condition provided by typeSpec string in the following format: 'isnumeric(x1)&amp;&amp;isa(x2,'int32')||isscalar(x2)' etc In case validation fails an exception is thrown. </p>
<pre class="fragment">*  Input:
*    regular:
*        typeSpec: char[1,]/function_handle - check string in
*            the folowing format: 'isnumeric(x)&amp;&amp;ischar(x)'
*                        OR
*            function_handle[1,1]
*        nPlaceHolders: numberic[1,1] - number of place holders/arguments in
*            typeSpec
* 
*        x1: anyType[]
*        x2: anyType[]
*        x3: anyType[]
* 
*    properties:
*        varNameList: cell[1,nVars] of char[1,] - list of variable names
*            used in the automatically generated error message.
*            Moreover the condition nVars&lt;=nPlaceHolders must hold.
*        errorTag: char[1,] - tag for MException object thrown
*            in case of error. If not specified
*            '&lt;CALLER_NAME&gt;:wrongInput' tag is used
*        errorMessage: char[1,] - error message for MException object
*            thrown in case of error. If not specified the message
*            is generated automatically.
*        nCallerStackStepsUp: numeric[1,1] - number of steps up in the call
*            stacks for the caller, by which name the full message tag is to
*            be generated, =1 by default
*  Example:
* 
*    mxberry.core.checkmultvar('numel(x1)==numel(x2)',2,a,b,%&gt;       'varNameList',{'Alpha'},'errorTag','wrongInput:badType',%&gt;       'errorMessage','Inputs are wrong')
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a01601968dba093ead278e8f4626d75ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01601968dba093ead278e8f4626d75ab">&#9670;&nbsp;</a></span>checksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::checksize </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHECKSIZE checks sizes of arrays;. </p>
<pre class="fragment">*  Usage isValid=checksize(arr1,arr2,arr3,siz);
* 
*  Input:
*    regular:
*        firstArr: any[]
*        %&gt;       lastArr: any[]
*        sizeVec: double[1,nDims] - mask for check of size;
* 
*  Output:
*    isValid: logical[1,1] - true if all arrays is proper with
*        mask
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a3984640ce480d5ab2ce2ac3bece4880f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3984640ce480d5ab2ce2ac3bece4880f">&#9670;&nbsp;</a></span>checkValueAndIsNullConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::checkValueAndIsNullConsistency </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>valueCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isNullCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nDimsCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isnValueVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3801c283d9a35a44097046e5b2757975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3801c283d9a35a44097046e5b2757975">&#9670;&nbsp;</a></span>checkvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::checkvar </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>typeSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHECKVAR checks a generic condition provided by typeSpec string in the following format: 'isnumeric(x)&amp;&amp;isa(x,'int32')||isscalar(x)' etc In case validation fails an exception is thrown. </p>
<pre class="fragment">*  Input:
*    regular:
*        x: anyType[]
*        typeSpec: char[1,]/function_handle - check string in
*            the folowing format: 'isnumeric(x)&amp;&amp;ischar(x)'
*                        OR
*            function_handle[1,1]
* 
*    optional:
*        varName: char[1,] - variable name - used optionally instead of
*            variable name determined auotmatically via inputname(1)
*    properties:
* 
*        errorTag: char[1,] - tag for MException object thrown
*            in case of error. If not specified
*            '&lt;CALLER_NAME&gt;wrongInput' tag is used
* 
*        errorMessage: char[1,] - error message for MException object
*            thrown in case of error. If not specified the message
*            is generated automatically.
* 
*        nCallerStackStepsUp: numeric[1,1] - number of steps up in the call
*            stacks for the caller, by which name the full message tag is to
*            be generated, =1 by default
*  Example:
*    mxberry.core.checkvar(int32(1),@(x)isa(x,'double'),'myVar',%&gt;       'errorTag','wrongInput:badType','errorMessage','Type is wrong')
* 
*    mxberry.core.checkvar([1,2],'iscol(x)','myVar',%&gt;       'errorTag','wrongInput:badType','errorMessage','Type is wrong')
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ad50a33874c11cfdc98b0591918ccd88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50a33874c11cfdc98b0591918ccd88d">&#9670;&nbsp;</a></span>combvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::combvec </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COMBVEC creates a matrix of combinations with elements from input vectors. </p>
<pre class="fragment">*  Usage: indMat=combvec(firstVec,secVec,)
* 
*  Input:
*    optional:
*        firstVec: numeric[1,n1Elems] - first vector
*        %&gt;       lastVec: numeric[1,nKElems] - last vector
* 
*  Output:
*    indMat: numeric[K,nCombs] - matrix with combinations from input vectors
* 
*  Example:
* 
*      firstVec=[1,2,3];
*      secVec=[4,5];
*      indMat=mxberry.core.combvec(firstVec,secVec);
*      indMat
* 
*      indMat =
* 
*           1     2     3     1     2     3
*           4     4     4     5     5     5
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ac6bee4f5988ab992a2e92437560be80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bee4f5988ab992a2e92437560be80a">&#9670;&nbsp;</a></span>createarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::createarray </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a1dbbf1cf602d8cfc82b5986b75558aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbbf1cf602d8cfc82b5986b75558aca">&#9670;&nbsp;</a></span>filesep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::filesep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ab4d9b0f9250251d7f6c8cef9ab467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab4d9b0f9250251d7f6c8cef9ab467d">&#9670;&nbsp;</a></span>genfilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::genfilename </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GENFILENAME generates a valid file name based on a given string. </p>
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a202a9ab0574c2b9892097c5f34363591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202a9ab0574c2b9892097c5f34363591">&#9670;&nbsp;</a></span>genteststruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::genteststruct </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GENTESTSTRUCT generates a complex test structure using input number to guarantee a uniqueness. </p>
<pre class="fragment">*  Input:
*    regular:
*        inpNum: numeric[1,1] - input number
* 
*  Output:
*    Data: struct[1,1] - resulting structure
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a5b769cc418c56926472a9306de4e4c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b769cc418c56926472a9306de4e4c8b">&#9670;&nbsp;</a></span>getcallername()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::getcallername </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nStepsUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GETCALLERNAME returns a name of caller determined by a number of steps up in the call stacks. </p>
<pre class="fragment">*  Input:
*    optional:
*        nStepsUp: numeric[1,1] - number of steps up in the call stacks,
*            =1 by default
*        mode: char [1,] - may be
*            'default' (default) - callerName equals to the class name in
*                the case of class, otherwise callerName equals to the name
*                of the corresponding function or script
*            'full' - callerName equals either to the name of the
*                corresponding function or script or to the name of class
*                concatenated through '.' with the name of method
* 
*  Output:
*    callerName: char[1,] - caller name
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a1f8533542a3914319395013ae4d7e0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8533542a3914319395013ae4d7e0ed">&#9670;&nbsp;</a></span>getcallernameext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::getcallernameext </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>indStack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GETCALLERNAME determines function/script name or method name of caller together with class name in the case it is method of class for element of stack given by its index (this index is 1 for immediate caller of this function) </p>
<pre class="fragment">*  Usage: methodName=getcallername() OR
*         [methodName,className]=getcallername()
*         methodName=getcallername(indStack) OR
*         [methodName,className]=getcallername(indStack)
* 
*  input:
*    optional:
*      indStack: double [1,1] - index of function/script or method in the
*          stack (this index is 1 for immediate caller of this function); by
*          default equals to 1 (i.e. immediate caller of this function)
*  output:
*    regular:
*      methodName: char - name of function/script or method
*      className: char - empty if it is not a method of some class,
*         otherwise name of the corresponding class
* 
*  Note: 1) In the case a caller is a method of some class, className
*           contains also info on packages, otherwise info on packages is
*           included into methodName. Thus, for example, for method
*           PCAForecast of equivolent.forecast.pca.PCAForecast class we
*           would have:
*             methodName='PCAForecast';
*             className='equivolent.forecast.pca.PCAForecast';
*           If we have function mxberry.core.num2cell, then we would have
*             methodName='mxberry.core.num2cell';
*             className='';
*           The last is true also for scripts.
*        2) In the case a caller is a subfunction of some method or function
*           methodName contains also the whole path to this subfunction, for
*           instance, for subfunction subfunc of function
*           package.subpackage.func we would have:
*             methodName='package.subpackage.func/subfunc';
*             className='';
*           Analogous situation is for scripts and methods of classes.
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a952b1b3051fc7c3c12f91b199cf8fba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952b1b3051fc7c3c12f91b199cf8fba7">&#9670;&nbsp;</a></span>getfirstdimsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::getfirstdimsize </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GETFIRSTDIMSIZE returns a size vector for the first N dimensions where N is specified. </p>
<pre class="fragment">*  Input:
*    regular:
*        value: array[] - input value
*        nDims: numeric[1,1] -
* 
*  Output:
*    sizeVec: double[1,nDims] - vector of input value sizes for the first
*       nDims dimensions
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ac0d6e3dc28b4b9ee8110355245399146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6e3dc28b4b9ee8110355245399146">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::hash </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>methodName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OBJECTHASH counts the hash of input object/array. </p>
<pre class="fragment">*  Usage: hashVec=objecthash(inpArr)
* 
*  Input:
*    regular:
*        inpArr: any[] - input array of practically arbitrary type
*        methodName: char[1,] - hash calculation method - one of the
*            following methods:'MD2','MD5','SHA-1','SHA-256','SHA-384',
*            'SHA-512'
* 
*  Output:
*    hashVec: char[1,] -  hash of the input object.
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ae39d705c2fd83dfb2f141212f4e334bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39d705c2fd83dfb2f141212f4e334bf">&#9670;&nbsp;</a></span>hashinner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::hashinner </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>meth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HASH - Convert an input variable into a message digest using any of several common hash algorithms. </p>
<pre class="fragment">*  USAGE: h = hash(inpArr,'meth')
* 
*  inpArr  = input variable, of any of the following classes:
*         char, uint8, logical, double, single, int8, uint8,
*         int16, uint16, int32, uint32, int64, uint64
*  h    = hash digest output, in hexadecimal notation
*  meth = hash algorithm, which is one of the following:
*         MD2, MD5, SHA-1, SHA-256, SHA-384, or SHA-512
* 
*  Note:
*        (1) If the input is a string or uint8 variable, it is hashed
*             as usual for a byte stream. Other classes are converted into
*             their byte-stream values. In other words, the hash of the
*             following will be identical:
*                      'abc'
*                      uint8('abc')
*                      char([97 98 99])
*             The hash of the follwing will be different from the above,
*             because class "double" uses eight byte elements:
*                      double('abc')
*                      [97 98 99]
*             You can avoid this issue by making sure that your inputs
*             are strings or uint8 arrays.
*         (2) The name of the hash algorithm may be specified in lowercase
*             and/or without the hyphen, if desired. For example,
*             h=hash('my text to hash','sha256');
*         (3) Carefully tested, but no warranty. Use at your own risk.
*         (4) Michael Kleder, Nov 2005
* 
*  Example:
* 
*      algs={'MD2','MD5','SHA-1','SHA-256','SHA-384','SHA-512'};
*      for n=1:6
*          h=mxberry.core.hash('my sample text',algs{n});
*          disp([algs{n} ' (' num2str(length(h)*4) ' bits):'])
*          disp(h)
*      end
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a561fa6e98a53b94b60600171acaffb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561fa6e98a53b94b60600171acaffb7d">&#9670;&nbsp;</a></span>ind2submat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ind2submat </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>sizeVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>indVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IND2SUBMAT works similarly to the built-in ind2sub function but returns all the indices in a single matrix. </p>
<pre class="fragment">*  Input:
*    regular:
*        sizeVec: numeric[1,nDims]
*        indVec: numeric[nIndices,1]/numeric[1,nIndices]
* 
*  Output:
*    indMat: double[nIndices,nDims] - matrix of subindices, each column
*        corresponds to a separate output of the built-in ind2sub function
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a52b876ee82367a95297f3ab6931f2ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b876ee82367a95297f3ab6931f2ab4">&#9670;&nbsp;</a></span>iscelllogical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::iscelllogical </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a109461a1489d1f085bc4da56824f5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109461a1489d1f085bc4da56824f5c21">&#9670;&nbsp;</a></span>iscellnumeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::iscellnumeric </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>valueArr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISCELLNUMERIC returns true for a cell arrays consisting of numeric elements only. </p>
<pre class="fragment">*  Input:
*    regular:
*        valueArr: any[nDim1,,nDimK] - arbitrary array, might not be a
*            cell array
* 
*  Output:
*    isPositive: logical[1,1] - if true, valueArr is composed of numeric
*        elements only
*    isPosElemArr: logicla[nDim1,,nDimK] - contains true values for those
*        elements that correspond to numeric elements in valueArr array
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2014-2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a24ab1159da81deb069aaa27924d7567b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ab1159da81deb069aaa27924d7567b">&#9670;&nbsp;</a></span>iscol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::iscol </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ac2e153653f73e458cc27d8d71bdf31ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e153653f73e458cc27d8d71bdf31ad">&#9670;&nbsp;</a></span>isequalcellelemsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isequalcellelemsize </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a6f589319675f973249a1bc82f7d3ac39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f589319675f973249a1bc82f7d3ac39">&#9670;&nbsp;</a></span>isequalfirstdimsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isequalfirstdimsize </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>firstArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>secArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISEQUALFIRSTDIMSIZE checks if the specified arrays have the same size along the first N dimensions where N is specified. </p>
<pre class="fragment">*  Input:
*    regular:
*        firstArr: any[] - first array of any type
*        secArr: any[] - second array of any type
*        nDims: double[1,1] - number of dimensions
* 
*  Output:
*   isPositive: logical[1,1] - true if the check is successfull
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a153b3936f6081b928368044bdfa108bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153b3936f6081b928368044bdfa108bb">&#9670;&nbsp;</a></span>isfirstdimsizeasspecified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isfirstdimsizeasspecified </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>valueArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>sizeVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISFIRSTDIMSIZEASSPECIFIED check if an input value have a specified size along the first dimensions. </p>
<pre class="fragment">*  Input:
*   regular:
*       valueArr: any[] - input array of any type
*        sizeVec: numeric[1,nDims] - expected size vec
* 
*  Output:
*    isPositive: logical[1,1] - true if the check is successful
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a128281605e1d3cd50f5879cedf252829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128281605e1d3cd50f5879cedf252829">&#9670;&nbsp;</a></span>ismember()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismember </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBER - ismember implementation for arrays of any type. </p>
<pre class="fragment">*  Usage: [isThereVec,indThereVec]=mxberry.core.ismember(leftVec,%&gt;   rightVec);
* 
*  Input:
*    regular:
*        leftVec: any[nObjectsLeft,1]
*        rightVec: any[nObjectsRight,1]
* 
*  Output:
*    isThereVec: logical[nObjectsLeft,1]
*    indThereVec: double[nObjectsLeft,1]
* 
*  Examples:
* 
*    leftVec={struct('a',1,'b',2)}
*    rightVec={struct('a',2,'b',2); struct('a',111,'g','555')}
*    [isThereVec,indThereVec]=mxberry.core.ismember(leftVec,rightVec,%&gt;       @(x,y)x.a==y.a)
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ace30cc5c07da6840ac0c59ba60af812f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace30cc5c07da6840ac0c59ba60af812f">&#9670;&nbsp;</a></span>ismemberbyfunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismemberbyfunc </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fCompare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBERBYFUNC - ismember implementation for arrays of any type where an element comparison is performed by a specified function. This function is useful when elements are not sortable i.e. EITHER an implementation of ,,,,, does not define a full order OR there is no an implementation of  method that calls these operators. </p>
<pre class="fragment">*  Usage: [isThereVec,indThereVec]=mxberry.core.ismemberbyfunc(leftVec,%&gt;   rightVec,fCompare);
* 
*  Input:
*    regular:
*        leftVec: any[nObjectsLeft,1]/[1,nObjectsLeft]
*        rightVec: any[nObjectsRight,1]/[1,nObjectsRight]
*    optional:
*       fCompare: function_handle[1,1] - an element comparison function,
*           default is @isequaln
* 
*  Output:
*    isThereVec: logical[nObjectsLeft,1]/[1,nObjectsLeft]
*    indThereVec: double[nObjectsLeft,1]/[1,nObjectsLeft]
* 
*  Examples:
* 
*    leftVec={struct('a',1,'b',2)}
*    rightVec={struct('a',2,'b',2); struct('a',111,'g','555')}
*    [isThereVec,indThereVec]=ismemberbyfunc(leftVec,rightVec,@(x,y)x.a==y.a)
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a7325f54bcfc06a4e4beb9d2038be34d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7325f54bcfc06a4e4beb9d2038be34d9">&#9670;&nbsp;</a></span>ismembercellstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismembercellstr </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isHigherIndexUsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBERCELLSTR produces the same results as the built-in function "ismember" looking for the higher index if isHigherIndexUsed =true and lower index if isHigherIndexUsed=false (default) </p>
<pre class="fragment">*  Input:
*    regular:
*        leftList: char[1,]/cell[1,nLeftElems] of char[1,] - list of strings
*        rightList: char[1,]/cell[1,nRightElems] of char[1,] - list of strings
*    optional:
*        isHigherIndexUsed: logical[1,1] - if true, higher index is
*            searched for, lower otherwise (default)
* 
*  Output:
*    isThereVec: logical[1,nLeftElems] - contains true for those elements of
*        aList for which a matching element is found in bList
*    indLocVec: double[1,nLeftElems] - contains indices for those elements of
*        aList for which(see above) and zero otherwise
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="afc85cadd1e23943f4244537dec5b7466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc85cadd1e23943f4244537dec5b7466">&#9670;&nbsp;</a></span>ismemberjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismemberjoint </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftCArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightCArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBERJOINT perform joint ismember operation for two cell arrays. </p>
<pre class="fragment">*  Usage: [isThereVec,indThereVec]=ismemberjoint(leftCArr,rightCArr)
* 
*  Input:
*    regular:
*        leftCArr: cell[n1,,nk] of any[] -cell array of arbitrary size,
*           in the case dim is not given (see below for
*           details) it is assumed that all cells must contain either
*           columns or rows of some type and of the same size (either
*           [1,nLeft] or [nLeft,1]); if dim is given then size of all items
*           in inpCell should be the same (and equal to nLeft) only along
*           dimension equal to dim
*        rightCArr: cell[n1,,nk] of any[] - cell array
*           of the same structure and size as leftCArr which
*           means that types and orientation (rows or columns, if dim is not
*           given) and size along other dimensions that dim (if the latter
*           is given) of respective cells in leftCArr and rightCArr should
*           be the same.
* 
*      Note: empty elements present in both leftCArr and rightCArr on
*             THE SAME PLACES are ignored
* 
*    optional:
*        dim: double [1,1] - main dimension along which ismemberjoint is
*            performed
* 
*        checkSizeIfEmpty: logical[1,1] - if true, then consistency of
*            sizes  of the corresponding cells in leftCArr and rightCArr is
*            performed even in the case one of them is empty along dimension
*            given by dim, if false, this check is omitted; by default it is
*            true
* 
*      Note: For other optional arguments and properties see descriptions of
*        mxberry.core.ismemberrows and mxberry.core.uniquerows functions
*        for their arguments immediately following after isInteger input
*        argument
* 
*  Output:
*    isThereVec: logical[nLeftElem,1]/[1,nLeft] array of membership indicators
*        of all respective elements within leftCArr to all respective
*        elements within rightCArr, nLeftElem is size of arrays contained
*        within leftCArr arrays for dimention dim
*    indThereVec: double[nLeftElem,1]/[1,nLeft]- indices indicating location of
*        respective elements within leftCArr in rightCArr elements
* 
*  Examples:
* 
*    [isThereVec,indThereVec]=ismemberjoint({[1 2],{'a','b'};[3%&gt;       4],{'c','d'}},{[1 2 3],{'a','b','c'};[3 4 5],{'c','d','m'}})
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a97fe0487e0a2ec01e41433b24dbc69d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fe0487e0a2ec01e41433b24dbc69d3">&#9670;&nbsp;</a></span>ismemberjointwithnulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismemberjointwithnulls </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftIsNullCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightIsNullCVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBERJOINTWITHNULLS perform joint ismember operation for two cell arrays for which also cell arrays detemining positions of null values are given. </p>
<pre class="fragment">*  Usage: [isMemberVec,indMemberVec]=ismemberjointwithnulls(%&gt;            leftCVec,leftIsNullCVec,rightCVec,rightIsNullCVec,dim)
* 
*  Input:
*    regular:
*        leftCVec: cell [1,nElems], all cells should contain arrays of
*            arbitrary types with size equal along dimension given by dim -
*            values of elements on the left
*        leftIsNullCVec: cell [1,nElems], i-th cell should contain logical
*            array with number of dimensions nDims_i and of sizes equal with
*            the ones for i-th cell within leftCVec along all dimensions
*            1..max(nDims_i,dim) - logical arrays determining what values are
*            null on the left
*        rightCVec: cell [1,nElems], all cells should contain arrays of
*            arbitrary types with size equal along dimension given by dim -
*            values of elements on the right
*        rightIsNullCVec: cell [1,nElems], i-th cell should contain logical
*            array with number of dimensions nDims_i and of sizes equal with
*            the ones for i-th cell within rightCVec along all dimensions
*            1..max(nDims_i,dim) - logical arrays determining what values are
*            null on the right
*    optional:
*        dim: double[1,1] - main dimension along which ismemberjointwithnulls
*            is performed; if not given, dim is taken equal to 1
*  Output:
*    isMemberVec: logical [nLeftElem,1] - array of membership indicators
*        of all respective elements within leftCVec (with taking into
*        account of leftIsNullCVec) to all respective elements within
*        rightCVec (with taking into account of rightIsNullCVec),
*        nLeftElem is size of arrays contained within leftCVec (and
*        leftIsNullCVec) arrays for dimention dim
*    indMemberVec: double [nLeftElem,1] - indices indicating location of
*        respective elements within leftCVec (with taking into account of
*        leftIsNullCVec) in rightCVec elements (with taking into account
*        of rightIsNullCVec)
* 
*  Example: [isMemberVec,indMemberVec]=ismemberjointwithnulls(%&gt;              {[1;2;1;2],{'a';'b';'c';'a'}},%&gt;              {[true;true;false;true],[true;true;true;false]},%&gt;              {[1;2;3],{'a';'b';'c'}},%&gt;              {[true;true;false],[true;true;true]},1);
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
</dd></dl>
<p>comparison may be done even if sizes of corresponding elements on left<br />
 and right sides are not equal along additional dimensions<br />
 </p>

</div>
</div>
<a id="ad824002c60eb4a84bc32715fcb944fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad824002c60eb4a84bc32715fcb944fef">&#9670;&nbsp;</a></span>ismemberrows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismemberrows </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpLeftMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpRightMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isInteger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>forceMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBERROWS finds indices of rows from the first matrix in the second matrix, i.e. it is the more efficient version of ISMEMBER(,'rows') </p>
<pre class="fragment">*  Usage: [isMemberVec,indMemberVec]=ismemberrows(inpLeftMat,inpRightMat)
* 
*  Input:
*    regular:
*        inpLeftMat: double/logical/char[nLeftRows,nCols] - first matrix
*        inpRightMat: double/logical/char[nRightRows,nCols] - second matrix
*    optional:
*       isInteger: logical[1,1] - if true then no checks that inpLeftMat and
*            inpRightMat contain finite integer values are performed
*        forceMode: char[1,] - if given, then determines mode to be used,
*            may be 'standard' (in this case built-in version is forced to
*          be used) or 'optimized' (then optimized version is to be used
*          instead of built-in one in the case it is possible)
*  Output:
*    isMemberVec: logical [nLeftRows,1] - whether corresponding row from
*        inpLeftMat equals to some row in matrix inpRightMat
*    indMemberVec: double [nLeftRows,1] - indices of corresponding rows
*        from inpLeftMat in matrix inpRightMat (0 if there is no equal row in b)
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a9d86d152881e2cdd55fe7249e2b6d7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d86d152881e2cdd55fe7249e2b6d7ba">&#9670;&nbsp;</a></span>ismembersortableobj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::ismembersortableobj </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>firstVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>secVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISMEMBER implementation strictly for sortable entities i.e. for those that have 1) full order defined by implementation of comparison operators /isequal/isequaln/isequaln, , , , ,  2) an implementation of  method that uses these operators. </p>
<pre class="fragment">*  Usage: [isThereVec,indThereVec]=%&gt;   mxberry.core.ismembersortableobj(leftVec,rightVec);
* 
*  Input:
*    regular:
*        leftVec: any[nObjectsLeft,1]
*        rightVec: any[nObjectsRight,1]
* 
*  Output:
*    isThereVec: logical[nObjectsLeft,1]
*    indThereVec: double[nObjectsLeft,1]
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a689f4e3e7f0a7816ca4c5b24338bbc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689f4e3e7f0a7816ca4c5b24338bbc7a">&#9670;&nbsp;</a></span>isrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isrow </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ade0bfe26af5d0622daabdb7737c6dbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0bfe26af5d0622daabdb7737c6dbf7">&#9670;&nbsp;</a></span>isunique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isunique </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a9595b6be2f2b7b8a2e664921ae8faa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9595b6be2f2b7b8a2e664921ae8faa96">&#9670;&nbsp;</a></span>isvalidsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isvalidsize </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISVALIDSIZE compares size of input arrays with size mask. Size mask can contain nans that allow any size for a corresponding dimension. Function automatically adds 1 at the end of size. For example, array 3x2 is also array 3x2x1 and 3x2x1x1x1 e.t.c;. </p>
<pre class="fragment">*  Usage isValid=isvalidsize(firstArr,secArr,lastArr,sizeVec);
* 
*  Input:
*    regular:
*        firstArr: any[]
*        secArr: any[]
*        %&gt;       lastArr: any[]
*        sizeVec: double[1,nDims] - mask for check of size, can contain
*            nans that mean that a corresponding dimension's size is ignored
* 
*  Output:
*    isValidVec: logical[1,N] - true if corresponding array is proper with
*        mask
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="af1edec5e1786e3aa6d8aabd094f07127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1edec5e1786e3aa6d8aabd094f07127">&#9670;&nbsp;</a></span>isvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isvar </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="acdc4013e2e25384e1b5e4c3365c7a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc4013e2e25384e1b5e4c3365c7a4a5">&#9670;&nbsp;</a></span>isvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::isvec </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a4ef6bf81b31117d7bc0664e07ac47b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef6bf81b31117d7bc0664e07ac47b45">&#9670;&nbsp;</a></span>num2cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::num2cell </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NUM2CELL is an extension of Matlab built-in function "num2cell" designed to work correctly with empty arrays (such as zero(10,0)) for instance. </p>
<pre class="fragment">*  Input and Output arguments are the same as for built-in num2cell function
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a4aace73b15b9a8915fef9c3d853a107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aace73b15b9a8915fef9c3d853a107d">&#9670;&nbsp;</a></span>parseparams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::parseparams </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>propNameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nRegExpected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>nPropExpected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PARSEPARAMS behaves exactly as a built-in Matlab function apart from the incorrect behavior of Matlab function in cases when the regular argument has a character type. Additionally the function allows to avoid a misinterpretation of symbolical values of regular parameters via listing all the allowed properties. </p>
<pre class="fragment">*  Input:
*    regular:
*        arg: cell[1,] list of input parameters to parse
* 
*    optional:
*        propNameList: cell[1,] of char[1,] - list of properties to recognize
*            this parameter can be useful for confusing the symbolical regular
*            arguments with the properties. For instance, if a character
*            value 'alpha' is expected to be recognized as a regular
*            parameter one can just list all the properties in propNameList
*            not including 'alpha' in the list.
* 
*          Note: property names are case-insensitive!
* 
*        nRegExpected: numeric[1,1]/[1,2] - an expected number of regular
*           arguments/range of regular argument numbers. If the actual
*           number doesn't mach the expected number an exception is thrown.
* 
*        nPropExpected: numeric[1,1] - an expected number of properties
* 
*  Output:
*    reg: cell[1,nRegs] - list of regular arguments
*    prop: cell[1,nProps*2] - list of property name-value pairs
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a1d4280be33b62043e3b51cac0cd2422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4280be33b62043e3b51cac0cd2422f">&#9670;&nbsp;</a></span>parseparext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::parseparext </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>propNameValMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PARSEPAREXT behaves in the same way as <a class="el" href="namespacemxberry_1_1core.html#a4aace73b15b9a8915fef9c3d853a107d" title="PARSEPARAMS behaves exactly as a built-in Matlab function apart from the incorrect behavior of Matlab...">mxberry.core.parseparams</a> but returns property values in a more convenient form. </p>
<pre class="fragment">*  Input:
*    regular:
*        arg: cell[1,] list of input parameters to parse
*        propNameValMat: cell[1-3,nExpProps] of char[1,]/cell[2,]
*            - list of properties to recognize
*            - and optionally the list of default values for properties
*            - and optionally the list of check strings for properties
*                (see mxberry.core.check.checkgen for check string
*                    syntax)
* 
*          Note: property names are case-insensitive!
* 
*    optional:
*        nRegExpected: numeric[1,1]/[1,2] - an expected number of regular
*           arguments/range of regular argument numbers. If the actual
*           number doesn't mach the expected number an exception is thrown.
* 
*        nPropExpected: numeric[1,1] - an expected number of properties
* 
*    properties:
*        regCheckList: cell[1,nRegMax] of char[1,] - list of regular
*            parameter check strings
* 
*        regDefList: cell[1,nRegMax] of any[] - list of regular parameter
*           values
* 
*        propRetMode: char[1,] - property return mode, the following modes
*            are supported
*                'list' - an aggregated list of specified properties
*                    is  returned instead of returning each property as
*                    a separate  output
*                'separate' - each property is returned separately followed
*                    isSpec indicator, this is a default method
* 
*        isObligatoryPropVec: logical[1,nExpProp] - indicates whether a
*            corresponding property from propNameValMat is obligatory. This
*            property can only be used when propNameValMat is not empty
* 
*        isDefaultPropSpecVec: logical[1,nExpProp] - indicates whetehr a
*            corresponding property has a default value. This property can
*            only be used when propRetMode='list'. Properties without
*            default values are not included into the resulting list
* 
*  Output:
*    reg: cell[1,nRegs] - list of regular parameters
* 
*    isRegSpecVec: logical[1,nRegs] - indicates whether a regular argument
*        specified
* 
*    ---------------"list" mode -----------------
*    prop: cell[1,nFilledProps]
*    isPropSpecVec: logical[1,nExpProps]
* 
*    ---------------"separate" mode
*    prop1Val: any[] - value of the first property specified by propNameValMat
*        %&gt;   propNVal: any[] - value of the last property specified by propNameValMat
* 
*    isProp1Spec: logical[1,1] - indicates whether the first property is
*        specified
*        %&gt;   isPropNSpec: logical[1,1] - indicates whether the last property is
*        specified
* 
*  Example:
*    [reg,isSpecVec,%&gt;       propVal1,propVal2,propVal3%&gt;       isPropVal1,isPropVal2,isPropVal3]=%&gt;       mxberry.core.parseparext({1,2,'prop1',3,'prop2',4},%&gt;       {'prop1','prop2','prop3';%&gt;       [],[],5;%&gt;       'isscalar(x)','isscalar(x)','isnumeric(x)'},%&gt;       [0 3],%&gt;       'regDefList',{1,2,3},%&gt;       'regCheckList',{'isnumeric(x)','isscalar(x)','isnumeric(x)'},%&gt;       'isObligatoryPropVec',[true true false])
* 
*  reg =   {1,2,3}
*  isSpecVec = [true,true,false]
*  propVal1 = 3
*  propVal2 = 4
*  propVal3 = 5
*  isPropVal1 =true
*  isPropVal2 =true
*  isPropVal3 =false
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="aa340f01d626482c5df08f7efc25b2c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340f01d626482c5df08f7efc25b2c03">&#9670;&nbsp;</a></span>parsestackelem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::parsestackelem </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SStackElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PARSESTACKELEM parses structure for given element of stack and returns the corresponding function/script name or method name together with class name in the case the element corresponds to some method of class. </p>
<pre class="fragment">*  Usage: methodName=parsestackelem(SStackElem) OR
*         [methodName,className]=parsestackelem(SStackElem)
* 
*  input:
*    regular:
*      SStackElem: struct [1,1] - structure with the same fields as those
*          that are given by dbstack (see info for dbstack for details)
*  output:
*    regular:
*      methodName: char - name of function/script or method
*      className: char - empty if it is not a method of some class,
*         otherwise name of the corresponding class
* 
*  Note: 1) In the case an element corresponds to a method of some class,
*           className contains also info on packages, otherwise info on
*           packages is included into methodName. Thus, for example, for
*           method PCAForecast of equivolent.forecast.pca.PCAForecast class
*           we would have:
*             methodName='PCAForecast';
*             className='equivolent.forecast.pca.PCAForecast';
*           If we have function mxberry.core.num2cell, then we would have
*             methodName='mxberry.core.num2cell';
*             className='';
*           The last is true also for scripts.
*        2) In the case an element corresponds to a subfunction of some
*           method or function methodName contains also the whole path to
*           this subfunction, for instance, for subfunction subfunc of
*           function package.subpackage.func we would have:
*             methodName='package.subpackage.func/subfunc';
*             className='';
*           Analogous situation is for scripts and methods of classes.
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>,<br />
 Ilya Roublev, PhD <a href="#" onclick="location.href='mai'+'lto:'+'iro'+'ub'+'lev'+'@g'+'mai'+'l.'+'com'; return false;">iroub<span style="display: none;">.nosp@m.</span>lev@<span style="display: none;">.nosp@m.</span>gmail<span style="display: none;">.nosp@m.</span>.com</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="af4013c197c3314c7c61f1abb527cddf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4013c197c3314c7c61f1abb527cddf8">&#9670;&nbsp;</a></span>repmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::repmat </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a4ff1ae4d47f235066962004643956ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff1ae4d47f235066962004643956ff6">&#9670;&nbsp;</a></span>roundn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::roundn </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>indexExp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROUNDN rounds to multiple of 10^indexExp. </p>
<pre class="fragment">*  Input:
*    regular:
*        inpArr: numeric[n1,,nk] - input real array
*        indexExp: numeric[1,1] - index exponent
*  Output:
*    outArr: numeric[n1,,nk] - array with rounded values
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ad34e5aaef1ed1c0bb395f7923ba05275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34e5aaef1ed1c0bb395f7923ba05275">&#9670;&nbsp;</a></span>smartcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::smartcat </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>xArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>yArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71b9de2eb47a731374160c16463c0223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b9de2eb47a731374160c16463c0223">&#9670;&nbsp;</a></span>structhash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::structhash </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>structB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>methodName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad02140bbba59721d1ddec37ff7d03512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02140bbba59721d1ddec37ff7d03512">&#9670;&nbsp;</a></span>subreffrontdim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::subreffrontdim </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>curInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2012-2015 Moscow State University,<br />
 Faculty of Applied Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a0418f02bf5876d905979cce7b8fdf7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0418f02bf5876d905979cce7b8fdf7ae">&#9670;&nbsp;</a></span>throwerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::throwerror </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>msgTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THROWERROR works similarly to built-in ERROR function in case when there is no output arguments but simpler to use as it automatically generates tags based on caller name When output argument is specified an exception object is returned instead. </p>
<pre class="fragment">*  Input:
*    regular:
*        msgTag: char[1,] error tag suffix which is complemented by
*            automatically generated part
*        %&gt;       same inputs as in error function
*        %&gt;   properties:
*        nCallerStackStepsUp: numeric[1,1] - number of steps up in the call
*            stacks for the caller, by which name the full message tag is to
*            be generated, =1 by default
* 
*  Output:
*    optional: meObj: MException[1,1]
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a4e469edaaf6fd2957f785d6523cdfe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e469edaaf6fd2957f785d6523cdfe45">&#9670;&nbsp;</a></span>unionjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::unionjoint </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIONJOINT calculates union of corresponding elements of two cell arrays jointly accross all cell array elements. </p>
<pre class="fragment">*  Usage: [unionCell,indLeft,indRight,indLocLeftVec,indLocRightVec]=unionjoint(leftCell,rightCell)
* 
*  Input:
*    regular:
*        leftCell: cell [n_1,n_2,,n_k] - first cell array
* 
*        rightCell: cell [n_1,n_2,,n_k] - second cell array
* 
*  Output:
*    unionCell: cell [n_1,n_2,,n_k] - resulting cell array
* 
*    indLeft: double [1,m_1] - indices of corresponding elements of leftCell
*       within unionCell
* 
*    indRight: double [1,m_2] - indices of corresponding elements of
*       rightCell in unionCell
* 
*    indLocLeftVec: double[1,max(m_1,m_2)] - for each element of unionCell
*        contains indices of elements of leftCell or zero otherwise
* 
*    indLocRightVec: double[1,max(m_1,m_2)] - for each element of unionCell
*        contains indices of elements of rightCell or zero otherwise
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
</dd></dl>
<p>%<br />
 </p>

</div>
</div>
<a id="a683f057478002dffe1fb0b609d149032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683f057478002dffe1fb0b609d149032">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::unique </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIQUE for arrays of any type. </p>
<pre class="fragment">*  Usage: [outUnqVec,indRightToLeftVec,indLeftToRightVec]=%&gt;   mxberry.core.unique(inpVec);
* 
*  Input:
*    regular:
*      inpVec: cell[nObjects,1]/[1,nObjects] of objects
* 
*  Output:
*    outUnqVec: cell[nUniqObjects,1]/[1,nUniqObjects]
*    indRightToLeftVec: double[nUniqObjects,1] : all
*        fCompare(inpVec(indRightToLeftVec)==outUnqVec)==true
*    indLeftToRightVec: double[nObjects,1] : all
*        all(fCompare(outUnqVec(indLeftToRightVec)==inpVec))
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a84dfbf027fe35478bed638e0bd8b1cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dfbf027fe35478bed638e0bd8b1cd2">&#9670;&nbsp;</a></span>uniquebyfunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::uniquebyfunc </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>algoName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIQUEBYFUNC unique for arrays of any type where an element comparison is performed by a specified function. </p>
<pre class="fragment">*  Usage: [outUnqVec,indRightToLeftVec,indLeftToRightVec]=uniquebyfunc(%&gt;           inpVec,fCompare);
* 
*  Input:
*    regular:
*        inpVec: any[nObjects,1] - input vector of objects
*    optional:
*        fCompare: function_handle[1,1] - an element comparison function,
*            default is @isequaln
*        algoName: char[1,] - can be one of
*            'memhungry' - faster but requires more RAM
*            'mempreserve' (DEFAULT) - RAM preserving but slower
* 
*  Output:
*    outUnqVec: cell[nUniqObjects,1]
*    indRightToLeftVec: double[nUniqObjects] : all
*        fCompare(inpVec(indRightToLeftVec)==outUnqVec)==true
*    indLeftToRightVec: double[nObjects,1] : all
*        all(fCompare(outUnqVec(indLeftToRightVec)==inpVec))
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ac4bf89f7fac5aec4aa10028a947f56c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bf89f7fac5aec4aa10028a947f56c2">&#9670;&nbsp;</a></span>uniquejoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::uniquejoint </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpCArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIQUEJOINT perform joint unique operation for cell arrays. </p>
<pre class="fragment">*  Usage: [uniqueCell,indRight2LeftVec,indLeft2RightVec]=uniquejoint(inpCell)
* 
*  Input:
*    regular:
*        inpCArr: cell [n_1,n_2,,n_k] - cell array;
*           in the case dim is not given (see below for details) it is
*           assumed that size of all items in inpCell should be the same
*           (either [1,nInp] or [nInp,1]); if dim is given then size of all
*           items in inpCell should be the same only along dimension equal
*           to dim
*    optional:
*        dim: double [1,1] - main dimension along which uniquejoint is
*            performed
* 
*        For other optional arguments and properties see description of
*        mxberry.core.uniquerows function for its arguments immediately
*        following after isInteger input argument
* 
*  Output:
*    uniqueCell: cell[n_1,n_2,,n_k] - cell array of the same size and
*        structure as inpCell but with shrinked items
* 
*    indRight2LeftVec: double[nUnique,1] - indices such that
*        uniqueCell=cellfun(@(x)x(indRight2LeftVec),inpCell,%&gt;           'UniformOutput',false)
*        if dim is not given, otherwise, for example, if dim=1, then
*        uniqueCell=cellfun(@(x)reshape(x(indRight2LeftVec,:),[%&gt;           numel(indRight2LeftVec) subsref(size(x),%&gt;           struct('type','()','subs',{{2:ndims(x)}}))]),inpCell,%&gt;           'UniformOutput',false)
* 
*    indLeft2RightVec: double[nInp,1] - indices such that
*        inpCell=cellfun(@(x)x(indLeft2Right),uniqueCell,%&gt;           'UniformOutput',false)
*        if dim is not given, otherwise, for example, if dim=1, then
*        inpCell=cellfun(@(x)reshape(x(indLeft2RightVec,:),[%&gt;           numel(indLeft2RightVec) subsref(size(x),%&gt;           struct('type','()','subs',{{2:ndims(x)}}))]),uniqueCell,%&gt;           'UniformOutput',false)
* 
*    isSorted: logical [1,1] - determines whether values in uniqueCell are
*        sorted or not; this function tries always to sort all values
*        in ascending order if it is possible jointly for all cells; if this
*        is possible then isSorted is true, otherwise isSorted is false and
*        hence there are some cells whose values are not sortable
* 
*  Examples:
* 
*      [uniqueCell,indRight2LeftVec,indLeft2RightVec]=%&gt;         uniquejoint({[1 2 1]; {'a','b','a'}})
*      [uniqueCell,indRight2LeftVec,indLeft2RightVec]=%&gt;         uniquejoint({[1 2;2 3;1 2],cat(3,{'a','c';'b','d';'a';'c'}%&gt;         {'e','f';'f','g';'e','f'}))
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
</dd></dl>
<p>TODO allow for cells containing 1-dimentional double arrays the same<br />
 size - unique(..,'rows') can be used for this case<br />
 </p>

</div>
</div>
<a id="a0019e12ebaeeade8bd08d11595154661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0019e12ebaeeade8bd08d11595154661">&#9670;&nbsp;</a></span>uniquerows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::uniquerows </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isInteger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>forceMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIQUEROWS finds unique rows in input matrix, i.e. the more effective version of UNIQUE(,'rows') </p>
<pre class="fragment">*  Usage: [uniqueMat,indRight2LeftVec,indLeft2RightVec]=uniquerows(inpMat)
* 
*  Input:
*   regular:
*       inpMat: double/logical/char [nRows,nCols] - input matrix
*    optional:
*        isInteger: logical [1,1] - if true then no checks that inpMat contain
*           finite integer values are performed
*        forceMode: char [1,] - if given, then determines mode to be used,
*           can take the following values:
*                'standard' (in this case built-in version is forced to
*                    be used)
*                'optimized' (then optimized version is to be used
*                    instead of built-in one in the case it is possible)
*  Output:
*    uniqueMat: double/logical/char [nUniqueRows,nCols] - output
*        matrix with unique rows
*    indRight2LeftVec: double [nUniqueRows,1] - indices such that
*        uniqueMat coincides with inpMat(indRight2LeftVec,:)
*    indLeft2RightVec: double [nRows,1] - indices such that
*        uniqueMat(indLeft2RightVec,:) coincides with inpMat
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a284ef547f3c9309906dd48d454cf71c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284ef547f3c9309906dd48d454cf71c0">&#9670;&nbsp;</a></span>uniquesortableobj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::uniquesortableobj </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>inpVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIQUE implementation strictly for sortable entities i.e. for those that have 1) full order defined by implementation of comparison operators /isequal/isequaln/isequaln, , , , ,  2) an implementation of  method that uses these operators. </p>
<pre class="fragment">*  Usage: [outUnqVec,indRightToLeftVec,indLeftToRightVec]=%&gt;   mxberry.core.uniquesortableobj(inpVec,fCompare);
* 
*  Input:
*    regular:
*      inpVec: cell[nObjects,1]/[1,nObjects] of objects
* 
*  Output:
*    outUnqVec: cell[nUniqObjects,1]/[1,nUniqObjects]
*    indRightToLeftVec: double[nUniqObjects,1] : all
*        fCompare(inpVec(indRightToLeftVec)==outUnqVec)==true
*    indLeftToRightVec: double[nObjects,1] : all
*        all(fCompare(outUnqVec(indLeftToRightVec)==inpVec))
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 1 2017 17:47:22 for MatrixBerryCore by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
