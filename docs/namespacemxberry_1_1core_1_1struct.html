<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MatrixBerryCore: mxberry::core::struct Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MatrixBerryCore
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemxberry.html">mxberry</a></li><li class="navelem"><a class="el" href="namespacemxberry_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacemxberry_1_1core_1_1struct.html">struct</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mxberry::core::struct Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemxberry_1_1core_1_1struct_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxberry_1_1core_1_1struct_1_1_a_struct_change_tracker.html">AStructChangeTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxberry_1_1core_1_1struct_1_1_struct_change_tracker.html">StructChangeTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCHANGETRACKER keeps a list of structure patches and provide tools for applying them to any arbitrary structure. Patches can be defined either as static or plain class methods A method must 1) have 'patch_' prefix and '_#' suffix 2) be public to be recognized as patch.  <a href="classmxberry_1_1core_1_1struct_1_1_struct_change_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxberry_1_1core_1_1struct_1_1_struct_change_tracker_empty_plug.html">StructChangeTrackerEmptyPlug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCHANGETRACKEREMPTYPLUG is an empty impementation of ASTRUCTCHANGETRACKER interface.  <a href="classmxberry_1_1core_1_1struct_1_1_struct_change_tracker_empty_plug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxberry_1_1core_1_1struct_1_1_struct_disp.html">StructDisp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is responsible for displaying structure outline.  <a href="classmxberry_1_1core_1_1struct_1_1_struct_disp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4707a317774544ef291b603ca3a014de"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a4707a317774544ef291b603ca3a014de">binaryunionstruct</a> (in leftStruct, in rightStruct, in fieldOpCell, in leftFieldOpCell, in rightFieldOpCell)</td></tr>
<tr class="memdesc:a4707a317774544ef291b603ca3a014de"><td class="mdescLeft">&#160;</td><td class="mdescRight">BINARYUNIONSTRUCT applies a set of binary operations to the fields of two structures, each operation can return multiple results.  <a href="#a4707a317774544ef291b603ca3a014de">More...</a><br /></td></tr>
<tr class="separator:a4707a317774544ef291b603ca3a014de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db5e799a9c3bb16d44a854efda1ba1"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a38db5e799a9c3bb16d44a854efda1ba1">updaterescell</a> ()</td></tr>
<tr class="separator:a38db5e799a9c3bb16d44a854efda1ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a53f24b6e6f27cd28af3c6db2cb9f5"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#ab5a53f24b6e6f27cd28af3c6db2cb9f5">binarynotdefined</a> (in varargin)</td></tr>
<tr class="separator:ab5a53f24b6e6f27cd28af3c6db2cb9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faef636b22e6530b8824104c3d6b6bb"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a6faef636b22e6530b8824104c3d6b6bb">auxcheckfuncell</a> (in fieldOpCell)</td></tr>
<tr class="separator:a6faef636b22e6530b8824104c3d6b6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4192ab61776a0288056c7e1c1a25eb"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#abc4192ab61776a0288056c7e1c1a25eb">fieldfilterstruct</a> (in InpStruct, in field2KeepList, in isCheckField)</td></tr>
<tr class="memdesc:abc4192ab61776a0288056c7e1c1a25eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIELDFILTERSTRUCT leaves in input structure array only specified fields.  <a href="#abc4192ab61776a0288056c7e1c1a25eb">More...</a><br /></td></tr>
<tr class="separator:abc4192ab61776a0288056c7e1c1a25eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f916860bac08f3936ed7ee5687d2a5e"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a3f916860bac08f3936ed7ee5687d2a5e">getleavelist</a> (in SInp)</td></tr>
<tr class="memdesc:a3f916860bac08f3936ed7ee5687d2a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GETLEAVELIST generates a list of structure leave paths.  <a href="#a3f916860bac08f3936ed7ee5687d2a5e">More...</a><br /></td></tr>
<tr class="separator:a3f916860bac08f3936ed7ee5687d2a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a68d1e0dcb47d421dca8856aae91e7"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a46a68d1e0dcb47d421dca8856aae91e7">getleavelistint</a> (in SInp)</td></tr>
<tr class="separator:a46a68d1e0dcb47d421dca8856aae91e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6ce4e15a24df9866064e9c74f371a"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#acdb6ce4e15a24df9866064e9c74f371a">pathfilterstruct</a> (in InpStruct, in path2KeepList)</td></tr>
<tr class="memdesc:acdb6ce4e15a24df9866064e9c74f371a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PATHFILTERSTRUCT leaves in input structure array only specified paths.  <a href="#acdb6ce4e15a24df9866064e9c74f371a">More...</a><br /></td></tr>
<tr class="separator:acdb6ce4e15a24df9866064e9c74f371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7314b57720a434109d797c64cdd548e2"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a7314b57720a434109d797c64cdd548e2">auxgetfieldstruct</a> (in SInp, in fieldName)</td></tr>
<tr class="separator:a7314b57720a434109d797c64cdd548e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1154a4aa4f80253c6432d0aef98d272a"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a1154a4aa4f80253c6432d0aef98d272a">sepcell2pathlist</a> (in sepCell)</td></tr>
<tr class="separator:a1154a4aa4f80253c6432d0aef98d272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e6952e085bf8fbd497b6f62e058181"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a97e6952e085bf8fbd497b6f62e058181">strucdisp</a> (in varargin)</td></tr>
<tr class="memdesc:a97e6952e085bf8fbd497b6f62e058181"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCDISP display structure outline.  <a href="#a97e6952e085bf8fbd497b6f62e058181">More...</a><br /></td></tr>
<tr class="separator:a97e6952e085bf8fbd497b6f62e058181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591c9bceb284ec6fbc0c564c0c07cd35"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a591c9bceb284ec6fbc0c564c0c07cd35">struct2str</a> (in SInp, in varargin)</td></tr>
<tr class="memdesc:a591c9bceb284ec6fbc0c564c0c07cd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCDISP display structure outline.  <a href="#a591c9bceb284ec6fbc0c564c0c07cd35">More...</a><br /></td></tr>
<tr class="separator:a591c9bceb284ec6fbc0c564c0c07cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d61b11d98b89deb11ee151453a9794"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a29d61b11d98b89deb11ee151453a9794">structapplypath</a> (in structB, in path, in value)</td></tr>
<tr class="memdesc:a29d61b11d98b89deb11ee151453a9794"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTAPPLYPATH for given a path '.a.b.c.d.' and a value and a structB, returns modified structB, so that structB.a.b.c.d==value;.  <a href="#a29d61b11d98b89deb11ee151453a9794">More...</a><br /></td></tr>
<tr class="separator:a29d61b11d98b89deb11ee151453a9794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ebed8719ecfad709cdada8d7ce50b5"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#ae2ebed8719ecfad709cdada8d7ce50b5">structcheckpath</a> (in SInpArr, in pathStr)</td></tr>
<tr class="memdesc:ae2ebed8719ecfad709cdada8d7ce50b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCHECKPATH for a given path ('a.b.c.d.' or {'a','b','c','d'} and a structure array SInpArr returns true, if this path exists for all structure array elements on any nesting level.  <a href="#ae2ebed8719ecfad709cdada8d7ce50b5">More...</a><br /></td></tr>
<tr class="separator:ae2ebed8719ecfad709cdada8d7ce50b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba6eacdaf27a8bb42e66793b85233e2"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#acba6eacdaf27a8bb42e66793b85233e2">structcompare</a> (in SX, in SY, in absTol, in relTol)</td></tr>
<tr class="memdesc:acba6eacdaf27a8bb42e66793b85233e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCOMPARE compares two structures using the specified tolerance.  <a href="#acba6eacdaf27a8bb42e66793b85233e2">More...</a><br /></td></tr>
<tr class="separator:acba6eacdaf27a8bb42e66793b85233e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cccfab3807690ed5aca38383e96f4e0"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a9cccfab3807690ed5aca38383e96f4e0">structcomparevec</a> (in SX, in SY, in absTol, in relTol)</td></tr>
<tr class="memdesc:a9cccfab3807690ed5aca38383e96f4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCOMPARE compares two structures using the specified tolerance.  <a href="#a9cccfab3807690ed5aca38383e96f4e0">More...</a><br /></td></tr>
<tr class="separator:a9cccfab3807690ed5aca38383e96f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506fa22d5359820ada8d2df6b89e2f20"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a506fa22d5359820ada8d2df6b89e2f20">structcompare1darray</a> (in SX, in SY, in absTol, in relTol)</td></tr>
<tr class="memdesc:a506fa22d5359820ada8d2df6b89e2f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCOMPARE1D compares 1-dimentional structural arrays.  <a href="#a506fa22d5359820ada8d2df6b89e2f20">More...</a><br /></td></tr>
<tr class="separator:a506fa22d5359820ada8d2df6b89e2f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f0814d79de183ac753126e5aab94c4"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#ae5f0814d79de183ac753126e5aab94c4">structcomparescalar</a> (in SX, in SY, in absTol, in relTol)</td></tr>
<tr class="memdesc:ae5f0814d79de183ac753126e5aab94c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTCOMPARE1D compares the scalar structures.  <a href="#ae5f0814d79de183ac753126e5aab94c4">More...</a><br /></td></tr>
<tr class="separator:ae5f0814d79de183ac753126e5aab94c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacd80f53b6ae66d064fceb539e31603"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#acacd80f53b6ae66d064fceb539e31603">compfun</a> (in x, in y, in absTol, in relTol)</td></tr>
<tr class="memdesc:acacd80f53b6ae66d064fceb539e31603"><td class="mdescLeft">&#160;</td><td class="mdescRight">COMPFUN compares two different objects (ideally - of any type)  <a href="#acacd80f53b6ae66d064fceb539e31603">More...</a><br /></td></tr>
<tr class="separator:acacd80f53b6ae66d064fceb539e31603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c0da4a2254016bb8786b25307de84e"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a76c0da4a2254016bb8786b25307de84e">toNumericSupportingMinus</a> (in x)</td></tr>
<tr class="separator:a76c0da4a2254016bb8786b25307de84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98a361710b283d5a413ee7f6d44fc96"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#af98a361710b283d5a413ee7f6d44fc96">structgetpath</a> (in SInpArr, in pathStr, in isPresenceChecked, in isJustCheck)</td></tr>
<tr class="memdesc:af98a361710b283d5a413ee7f6d44fc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">STRUCTGETPATH extract a value from a given structure array using a path specified either as a string or as a sequence of field names separated by dots. It is assumed that all values located at the specified path are of the same size.  <a href="#af98a361710b283d5a413ee7f6d44fc96">More...</a><br /></td></tr>
<tr class="separator:af98a361710b283d5a413ee7f6d44fc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318dfa55c5492451562a947c8706012"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a2318dfa55c5492451562a947c8706012">getField</a> (in SInpArr, in fieldName, in isPresenceChecked)</td></tr>
<tr class="separator:a2318dfa55c5492451562a947c8706012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6c86fe1adfdd21cbe9c2c78c5285ce"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#abc6c86fe1adfdd21cbe9c2c78c5285ce">unionstructsalongdim</a> (in catDimension, in varargin)</td></tr>
<tr class="memdesc:abc6c86fe1adfdd21cbe9c2c78c5285ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIONSTRUCTS unites structures with the same fields by concatenating the corresponding fields along the specified dimension.  <a href="#abc6c86fe1adfdd21cbe9c2c78c5285ce">More...</a><br /></td></tr>
<tr class="separator:abc6c86fe1adfdd21cbe9c2c78c5285ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c802d07c9eccf171553ff16f693fb00"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a9c802d07c9eccf171553ff16f693fb00">updateleaves</a> (in SData, in fUpdateFunc)</td></tr>
<tr class="memdesc:a9c802d07c9eccf171553ff16f693fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">UPDATELEAVES applies the specified function to each structure leave value and returns the updated structure.  <a href="#a9c802d07c9eccf171553ff16f693fb00">More...</a><br /></td></tr>
<tr class="separator:a9c802d07c9eccf171553ff16f693fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c15f985f138c3dcaee8ceeca92f371"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a02c15f985f138c3dcaee8ceeca92f371">fUpdateExtFunc</a> (in val, in path)</td></tr>
<tr class="separator:a02c15f985f138c3dcaee8ceeca92f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b14824583e673bbeea9893518641b48"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a8b14824583e673bbeea9893518641b48">updateleavesext</a> (in SData, in fUpdateFunc)</td></tr>
<tr class="memdesc:a8b14824583e673bbeea9893518641b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">UPDATELEAVESEXT applies the specified function to each structure leave value and returns the updated structure, potentially with changed field paths.  <a href="#a8b14824583e673bbeea9893518641b48">More...</a><br /></td></tr>
<tr class="separator:a8b14824583e673bbeea9893518641b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca0b244a80ee21b0187891fdff18450"><td class="memItemLeft" align="right" valign="top">function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxberry_1_1core_1_1struct.html#a4ca0b244a80ee21b0187891fdff18450">setSDataField</a> (in subFieldNameList, in value)</td></tr>
<tr class="separator:a4ca0b244a80ee21b0187891fdff18450"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6faef636b22e6530b8824104c3d6b6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6faef636b22e6530b8824104c3d6b6bb">&#9670;&nbsp;</a></span>auxcheckfuncell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::auxcheckfuncell </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fieldOpCell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7314b57720a434109d797c64cdd548e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7314b57720a434109d797c64cdd548e2">&#9670;&nbsp;</a></span>auxgetfieldstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::auxgetfieldstruct </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a53f24b6e6f27cd28af3c6db2cb9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a53f24b6e6f27cd28af3c6db2cb9f5">&#9670;&nbsp;</a></span>binarynotdefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::binarynotdefined </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4707a317774544ef291b603ca3a014de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4707a317774544ef291b603ca3a014de">&#9670;&nbsp;</a></span>binaryunionstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::binaryunionstruct </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fieldOpCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>leftFieldOpCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>rightFieldOpCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BINARYUNIONSTRUCT applies a set of binary operations to the fields of two structures, each operation can return multiple results. </p>
<pre class="fragment">*  Usage:
*    [S1,S2,S3,,Sn]=binaryunionstruct(leftStruct,rightStruct,%&gt;       fieldOpCell,leftFieldOpCell,rightFieldOpCell)
* 
*  Input:
*    regular:
*        leftStruct: struct[n1,n2,,nk] - first input structure array
* 
*        rightStruct: struct[n1,n2,,nk] - second input structure array
* 
*        fieldOpCell: cell[1,nOps] - cell array of operations applied
*           to common fileds of two structures, each operation should return
*              n arguments
* 
*    optional:
* 
*        leftFieldOpCell: cell[1,nOps] - cell array of operations that
*           applied to the fields that are present only in the first
*              structure, each operation should return n arguments
* 
*                default value: @deal
* 
*        rightFieldOpCell: cell[1,nOps] - cell array of operations that
*           applied to the fields that are present only in the second
*           structure, each operation should return n arguments
* 
*                default value: @deal
* 
*  Output:
*    S1: struct [n1,n2,,nk,nOps] - contains the first outputs from operations
*    S2: struct [n1,n2,,nk,nOps] - contains the second outputs from operations
*    %&gt;   Sn: struct [n1,n2,,nk,nOps] - contains n'th outputs from operatons
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="acacd80f53b6ae66d064fceb539e31603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacd80f53b6ae66d064fceb539e31603">&#9670;&nbsp;</a></span>compfun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::compfun </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COMPFUN compares two different objects (ideally - of any type) </p>

</div>
</div>
<a id="abc4192ab61776a0288056c7e1c1a25eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4192ab61776a0288056c7e1c1a25eb">&#9670;&nbsp;</a></span>fieldfilterstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::fieldfilterstruct </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>InpStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>field2KeepList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isCheckField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FIELDFILTERSTRUCT leaves in input structure array only specified fields. </p>
<pre class="fragment">*  Usage: ResStruct=fieldfilterstruct(InpStruct,field2KeepList)
* 
*  input:
*    regular:
*        mandatory:
*            inpStruct: struct[multydimensional] - struct array;
*            field2KeepList: cell[1,nFields] - names of fields to leave;
*        optional:
*            isCheckField: logical[1] - if it is true all names from
*                    field2KeepList have to be names of fields from
*                    InpStruct or function displays error message;
*                    by default false;
*  output:
*    regular:
*       ResStruct: struct[multydimensional] - struct array of the same size
*                as inpStruct;
* 
*  Example:  ResStruct=fieldfilterstruct(InpStruct,{'a','b'})
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a02c15f985f138c3dcaee8ceeca92f371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c15f985f138c3dcaee8ceeca92f371">&#9670;&nbsp;</a></span>fUpdateExtFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::fUpdateExtFunc </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2318dfa55c5492451562a947c8706012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2318dfa55c5492451562a947c8706012">&#9670;&nbsp;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::getField </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isPresenceChecked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f916860bac08f3936ed7ee5687d2a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f916860bac08f3936ed7ee5687d2a5e">&#9670;&nbsp;</a></span>getleavelist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::getleavelist </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GETLEAVELIST generates a list of structure leave paths. </p>
<pre class="fragment">*  Input:
*    regular:
*        SInp: struct[] - input structure array
* 
*  Output:
*    pathSpecList: cell[nPaths,1] of cell[1,] of char[1,]/cell[1,] of double[1,]
* 
*        - list of path specifications in the following form:
*            {{ind11,ind12,,ind1n1},field1,%&gt;               {ind21,ind22,,ind2n2},field2,%&gt;               {ind31,ind32,,ind3n3},field3}
*                which corresponds to
*            S(ind11,ind12,,ind1n1).field1(%&gt;               ind21,ind22,,ind2n2).field2(%&gt;               ind31,ind32,,ind3n3).field3
* 
*   valueList: cell[nPaths,1] of any[] - list of leave  values
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a46a68d1e0dcb47d421dca8856aae91e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a68d1e0dcb47d421dca8856aae91e7">&#9670;&nbsp;</a></span>getleavelistint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::getleavelistint </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb6ce4e15a24df9866064e9c74f371a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb6ce4e15a24df9866064e9c74f371a">&#9670;&nbsp;</a></span>pathfilterstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::pathfilterstruct </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>InpStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>path2KeepList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PATHFILTERSTRUCT leaves in input structure array only specified paths. </p>
<pre class="fragment">*  Usage: ResStruct=pathfilterstruct(InpStruct,field2KeepList)
* 
*  Input:
*    regular:
*        InpStruct: struct array
*        path2KeepList: cell[1,nPaths] - cell array of strings with paths in
*                structure;
*  Output:
*    regular:
*        ResStruct: struct array
* 
*  Example:  ResStruct=pathfilterstruct(InpStruct,{'a','a.b','cd.u','.m'})
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a1154a4aa4f80253c6432d0aef98d272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1154a4aa4f80253c6432d0aef98d272a">&#9670;&nbsp;</a></span>sepcell2pathlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::sepcell2pathlist </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>sepCell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ca0b244a80ee21b0187891fdff18450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca0b244a80ee21b0187891fdff18450">&#9670;&nbsp;</a></span>setSDataField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::setSDataField </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>subFieldNameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97e6952e085bf8fbd497b6f62e058181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e6952e085bf8fbd497b6f62e058181">&#9670;&nbsp;</a></span>strucdisp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::strucdisp </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCDISP display structure outline. </p>
<pre class="fragment">*  Usage: STRUCDISP(STRUC,fileName,'depth',DEPTH,'printValues',PRINTVALUES,%&gt;           'maxArrayLength',MAXARRAYLENGTH) stores
*         the hierarchical outline of a structure and its substructures into
*         the specified file
* 
*  Input:
*    regular:
*        SInp: struct[1,1] - is a structure datatype with unknown field
*            content. It can be  either a scalar or a vector, but not a
*            matrix. STRUC is the only mandatory argument in this function.
*            All other arguments are optional.
* 
*    optional
*        fileName: char[1,] is the name of the file to which the output
*            should be printed. if this argument is not defined, the output
*            is printed to the command window.
* 
*    properties
*        depth: numeric[1,1] - the number of hierarchical levels of
*            the structure that are printed. If DEPTH is smaller than zero,
*            all levels are printed. Default value for DEPTH is -1
*            (print all levels).
* 
*        printValues: logical[1,1] -  flag that states if the field values
*            should be printed  as well. The default value is 1 (print values)
* 
*        maxArrayLength: numberic[1,1] - a positive integer,
*            which determines up to which length or size the values of
*            a vector or matrix are printed. For a  vector holds that
*            if the length of the vector is smaller or equal to
*            MAXARRAYLENGTH, the values are printed. If the vector is
*            longer than MAXARRAYLENGTH, then only the size of the
*            vector is printed. The values of a 2-dimensional (m,n)
*            array are printed if the number of elements (m x n) is
*            smaller or equal to MAXARRAYLENGTH. For vectors and arrays,
*            this constraint overrides the PRINTVALUES flag.
*        numberFormat: char[1,] - format specification used for displaying
*            numberic values, passed directly to sprintf, by default '%g' is
*            used
*  Output:
*    regular:
*        resStr: char [1,] - resulting string with displayed
*            structure contents
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a591c9bceb284ec6fbc0c564c0c07cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591c9bceb284ec6fbc0c564c0c07cd35">&#9670;&nbsp;</a></span>struct2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::struct2str </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCDISP display structure outline. </p>
<pre class="fragment">*  Usage: STRUCT2STR(STRUC,fileName,'depth',DEPTH,'printValues',PRINTVALUES,%&gt;           'maxArrayLength',MAXARRAYLENGTH) stores
*         the hierarchical outline of a structure and its substructures into
*         the specified file
* 
*  Input:
*    regular:
*        SInp: struct[1,1] - is a structure datatype with unknown field
*            content. It can be  either a scalar or a vector, but not a
*            matrix. STRUC is the only mandatory argument in this function.
*            All other arguments are optional.
* 
*    optional
*        fileName: char[1,] is the name of the file to which the output
*            should be printed. if this argument is not defined, the output
*            is printed to the command window.
* 
*    properties
*        depth: numeric[1,1] - the number of hierarchical levels of
*            the structure that are printed. If DEPTH is smaller than zero,
*            all levels are printed. Default value for DEPTH is -1
*            (print all levels).
* 
*        printValues: logical[1,1] -  flag that states if the field values
*            should be printed  as well. The default value is 1 (print values)
* 
*        maxArrayLength: numeric[1,1] - a positive integer,
*            which determines up to which length or size the values of
*            a vector or matrix are printed. For a  vector holds that
*            if the length of the vector is smaller or equal to
*            MAXARRAYLENGTH, the values are printed. If the vector is
*            longer than MAXARRAYLENGTH, then only the size of the
*            vector is printed. The values of a 2-dimensional (m,n)
*            array are printed if the number of elements (m x n) is
*            smaller or equal to MAXARRAYLENGTH. For vectors and arrays,
*            this constraint overrides the PRINTVALUES flag.
*        numberFormat: char[1,] - format specification used for displaying
*            numberic values, passed directly to sprintf, by default '%g' is
*            used
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a29d61b11d98b89deb11ee151453a9794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d61b11d98b89deb11ee151453a9794">&#9670;&nbsp;</a></span>structapplypath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structapplypath </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>structB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTAPPLYPATH for given a path '.a.b.c.d.' and a value and a structB, returns modified structB, so that structB.a.b.c.d==value;. </p>
<pre class="fragment">*  Usage: structB=structapplypath(structB,path,value)
* 
*  input:
*    regular:
*        structB - a struct
*        path: string, 'a.b.c.d', in this case 'a' is ignored, and the value
*            is stored in structB.b.c.d, the correct path begins from dot.
*        value: value to be stored
* 
*  output:
*    regular:
*        structB - a struct
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="ae2ebed8719ecfad709cdada8d7ce50b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ebed8719ecfad709cdada8d7ce50b5">&#9670;&nbsp;</a></span>structcheckpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structcheckpath </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>pathStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTCHECKPATH for a given path ('a.b.c.d.' or {'a','b','c','d'} and a structure array SInpArr returns true, if this path exists for all structure array elements on any nesting level. </p>
<pre class="fragment">*  Usage: isPos=structcheckpath(SInpArr,pathStr)
* 
*  Input:
*    regular:
*        SInpArr: struct[] - input structure array of arbitrary size
*        pathStr: char[1,]/cell[1,] of char[1,] - path to check
* 
*  Output:
*    isPos: logical[1,1] - true if the path SInp exists in the structure
*        pathStr
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2011-2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="acba6eacdaf27a8bb42e66793b85233e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba6eacdaf27a8bb42e66793b85233e2">&#9670;&nbsp;</a></span>structcompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structcompare </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTCOMPARE compares two structures using the specified tolerance. </p>
<pre class="fragment">*  Input:
*    regular:
*        S1: struct[] - first input structure
*        S2: struct[] - second input structure
*    optional:
*        absTol: double[1,1] - maximum allowed tolerance, default value is 0
*        relTol: double[1,1] - maximum allowed relative tolerance, isn't
*                              used by default
* 
* 
*  Output:
*    isEqual: logical[1,1] - true if the structures are found equal
*    reportStr: char[1,1] report about the found differences
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a506fa22d5359820ada8d2df6b89e2f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506fa22d5359820ada8d2df6b89e2f20">&#9670;&nbsp;</a></span>structcompare1darray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structcompare1darray </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTCOMPARE1D compares 1-dimentional structural arrays. </p>

</div>
</div>
<a id="ae5f0814d79de183ac753126e5aab94c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f0814d79de183ac753126e5aab94c4">&#9670;&nbsp;</a></span>structcomparescalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structcomparescalar </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTCOMPARE1D compares the scalar structures. </p>

</div>
</div>
<a id="a9cccfab3807690ed5aca38383e96f4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cccfab3807690ed5aca38383e96f4e0">&#9670;&nbsp;</a></span>structcomparevec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structcomparevec </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>absTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>relTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTCOMPARE compares two structures using the specified tolerance. </p>
<pre class="fragment">*  Input:
*    regular:
*        SLeft: struct[] - first input structure array
*        SRight: struct[] - second input structure array
*    optional:
*        absTol: double[1,1] - maximum allowed tolerance, default value is 0
*        relTol: double[1,1] - maximum allowed relative tolerance, isn't
*                              used by default
* 
*  Output:
*    isEqualVec: logical[1,] - true if the structures are found equal
*    reportStr: char[1,] report about the found differences
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a>,<br />
 Vadim Kaushansky, PhD <a href="#" onclick="location.href='mai'+'lto:'+'vka'+'us'+'han'+'sk'+'iy@'+'gm'+'ail'+'.c'+'om'; return false;">vkaus<span style="display: none;">.nosp@m.</span>hans<span style="display: none;">.nosp@m.</span>kiy@g<span style="display: none;">.nosp@m.</span>mail<span style="display: none;">.nosp@m.</span>.com</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Cybernetics,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="af98a361710b283d5a413ee7f6d44fc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98a361710b283d5a413ee7f6d44fc96">&#9670;&nbsp;</a></span>structgetpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::structgetpath </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SInpArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>pathStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isPresenceChecked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>isJustCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STRUCTGETPATH extract a value from a given structure array using a path specified either as a string or as a sequence of field names separated by dots. It is assumed that all values located at the specified path are of the same size. </p>
<pre class="fragment">*  Usage:
*    SRes=structgetpath(SInpArr,pathStr)
*    SRes=structgetpath(SInpArr,pathStr,false)
* 
*  Input:
*    regular:
*        SInpArr: struct[] - input struct array
*        pathStr: char[1,]/cell[1,] of char[1,] - path in the SInp
*        isPresenceChecked: logical[1,1] - if true, the function doesn't
*            throw an exception if the path is not found and returns
*            isThere=false instead.
*                Default value is FALSE.
*        isJustCheck: logical[1,1] - if true, no value is extracted, just a
*            presence of the specified path is checked. When
*            isJustCheck=true isPresenceChecked is automatically set to true
*                Default value is FALSE.
* 
*    Note: when isJustCheck=true the function is more prohibitive as it
*        doesn't check for consistency of sizes for values of different
*        structure array elements. However, when isJustCheck=false the
*        function attempts to extract values concatenating them via cell2mat
*        function. This may result into either a failure
*        (isPresenceChecked=false) or isThere=false when
*        (isPresenceChecked=true) even if with isJustCheck=true the function
*        returned isThere=true.
* 
*  Output:
*    SRes: struct[] - struct array of the same size as SInpArr
*    isThere: logical[1,1] - if false, the specified path is not found in
*        SInpArr
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2011-2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a76c0da4a2254016bb8786b25307de84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c0da4a2254016bb8786b25307de84e">&#9670;&nbsp;</a></span>toNumericSupportingMinus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::toNumericSupportingMinus </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc6c86fe1adfdd21cbe9c2c78c5285ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6c86fe1adfdd21cbe9c2c78c5285ce">&#9670;&nbsp;</a></span>unionstructsalongdim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::unionstructsalongdim </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>catDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>varargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UNIONSTRUCTS unites structures with the same fields by concatenating the corresponding fields along the specified dimension. </p>
<pre class="fragment">*  Input:
*    regular:
*        catDimension: numeric[1,1] - dimension number along which the
*           concatenation is to be performed
* 
*    optional:
*        struct1: struct[n1,n2,,n_k]
*        %&gt;       structN: struct[n1,n2,,n_k]
* 
* 
*  Output:
*    SRes: struct[n1,n2,,n_k] - resulting structure
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a9c802d07c9eccf171553ff16f693fb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c802d07c9eccf171553ff16f693fb00">&#9670;&nbsp;</a></span>updateleaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::updateleaves </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fUpdateFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UPDATELEAVES applies the specified function to each structure leave value and returns the updated structure. </p>
<pre class="fragment">*  Input:
*    regular:
*        SData: struct[1,1] - input data structure
*        fUpdateFunc: function_handle[1,1] - function with 2 input
*            arguments: field value and field path and 1 output argument -
*            updated field value
* 
*  Output
*    SData: struct[1,1] - updated structure
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a8b14824583e673bbeea9893518641b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b14824583e673bbeea9893518641b48">&#9670;&nbsp;</a></span>updateleavesext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::updateleavesext </td>
          <td>(</td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>SData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in&#160;</td>
          <td class="paramname"><em>fUpdateFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UPDATELEAVESEXT applies the specified function to each structure leave value and returns the updated structure, potentially with changed field paths. </p>
<pre class="fragment">*  Input:
*    regular:
*        SData: struct[1,1] - input data structure
*        fUpdateFunc: function_handle[1,1] - function with 2 input
*            arguments: field value and field path and 2 output argument -
*            updated field value and updated field path
* 
*  Output
*    SData: struct[1,1] - updated structure
* </pre> <dl class="section author"><dt>Author</dt><dd>Peter Gagarinov, PhD <a href="#" onclick="location.href='mai'+'lto:'+'pga'+'ga'+'rin'+'ov'+'@gm'+'ai'+'l.c'+'om'; return false;">pgaga<span style="display: none;">.nosp@m.</span>rino<span style="display: none;">.nosp@m.</span>v@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> <br />
 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2015-2016 Peter Gagarinov, PhD<br />
 2015 Moscow State University,<br />
 Faculty of Computational Mathematics and Computer Science,<br />
 System Analysis Department<br />
 </dd></dl>

</div>
</div>
<a id="a38db5e799a9c3bb16d44a854efda1ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38db5e799a9c3bb16d44a854efda1ba1">&#9670;&nbsp;</a></span>updaterescell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function mxberry::core::struct::updaterescell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated for MatrixBerryCore by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>